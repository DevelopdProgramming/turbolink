// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto

#pragma warning (disable : 4800)
#pragma warning (disable : 4125)
#pragma warning (disable : 4647)
#pragma warning (disable : 4668)
#pragma warning (disable : 4582)
#pragma warning (disable : 4583)
#pragma warning (disable : 4946)
#pragma warning (disable : 4577)

#ifdef _MSC_VER
#include "Windows/AllowWindowsPlatformTypes.h"
#endif

#include "gtfs-realtime.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace transit_realtime {
template <typename>
PROTOBUF_CONSTEXPR FeedMessage::FeedMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_)*/{}
  , /*decltype(_impl_.header_)*/nullptr} {}
struct FeedMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeedMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeedMessageDefaultTypeInternal() {}
  union {
    FeedMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeedMessageDefaultTypeInternal _FeedMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeedHeader::FeedHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.gtfs_realtime_version_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.timestamp_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.incrementality_)*/ 0
} {}
struct FeedHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeedHeaderDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeedHeaderDefaultTypeInternal() {}
  union {
    FeedHeader _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeedHeaderDefaultTypeInternal _FeedHeader_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR FeedEntity::FeedEntity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trip_update_)*/nullptr
  , /*decltype(_impl_.vehicle_)*/nullptr
  , /*decltype(_impl_.alert_)*/nullptr
  , /*decltype(_impl_.shape_)*/nullptr
  , /*decltype(_impl_.stop_)*/nullptr
  , /*decltype(_impl_.trip_modifications_)*/nullptr
  , /*decltype(_impl_.is_deleted_)*/ false
} {}
struct FeedEntityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FeedEntityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~FeedEntityDefaultTypeInternal() {}
  union {
    FeedEntity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FeedEntityDefaultTypeInternal _FeedEntity_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripUpdate_StopTimeEvent::TripUpdate_StopTimeEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_)*/ ::int64_t{0}

  , /*decltype(_impl_.delay_)*/ 0

  , /*decltype(_impl_.uncertainty_)*/ 0
} {}
struct TripUpdate_StopTimeEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripUpdate_StopTimeEventDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripUpdate_StopTimeEventDefaultTypeInternal() {}
  union {
    TripUpdate_StopTimeEvent _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripUpdate_StopTimeEventDefaultTypeInternal _TripUpdate_StopTimeEvent_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate_StopTimeProperties::TripUpdate_StopTimeUpdate_StopTimeProperties(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.assigned_stop_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal() {}
  union {
    TripUpdate_StopTimeUpdate_StopTimeProperties _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripUpdate_StopTimeUpdate_StopTimePropertiesDefaultTypeInternal _TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdate::TripUpdate_StopTimeUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.arrival_)*/nullptr
  , /*decltype(_impl_.departure_)*/nullptr
  , /*decltype(_impl_.stop_time_properties_)*/nullptr
  , /*decltype(_impl_.stop_sequence_)*/ 0u

  , /*decltype(_impl_.schedule_relationship_)*/ 0

  , /*decltype(_impl_.departure_occupancy_status_)*/ 0
} {}
struct TripUpdate_StopTimeUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripUpdate_StopTimeUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripUpdate_StopTimeUpdateDefaultTypeInternal() {}
  union {
    TripUpdate_StopTimeUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripUpdate_StopTimeUpdateDefaultTypeInternal _TripUpdate_StopTimeUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripUpdate_TripProperties::TripUpdate_TripProperties(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trip_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_date_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_time_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.shape_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct TripUpdate_TripPropertiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripUpdate_TripPropertiesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripUpdate_TripPropertiesDefaultTypeInternal() {}
  union {
    TripUpdate_TripProperties _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripUpdate_TripPropertiesDefaultTypeInternal _TripUpdate_TripProperties_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripUpdate::TripUpdate(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_time_update_)*/{}
  , /*decltype(_impl_.trip_)*/nullptr
  , /*decltype(_impl_.vehicle_)*/nullptr
  , /*decltype(_impl_.trip_properties_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.delay_)*/ 0
} {}
struct TripUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripUpdateDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripUpdateDefaultTypeInternal() {}
  union {
    TripUpdate _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripUpdateDefaultTypeInternal _TripUpdate_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR VehiclePosition_CarriageDetails::VehiclePosition_CarriageDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.label_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.carriage_sequence_)*/ 0u

  , /*decltype(_impl_.occupancy_status_)*/ 7

  , /*decltype(_impl_.occupancy_percentage_)*/ -1
} {}
struct VehiclePosition_CarriageDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VehiclePosition_CarriageDetailsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VehiclePosition_CarriageDetailsDefaultTypeInternal() {}
  union {
    VehiclePosition_CarriageDetails _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VehiclePosition_CarriageDetailsDefaultTypeInternal _VehiclePosition_CarriageDetails_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR VehiclePosition::VehiclePosition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.multi_carriage_details_)*/{}
  , /*decltype(_impl_.stop_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trip_)*/nullptr
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.vehicle_)*/nullptr
  , /*decltype(_impl_.current_stop_sequence_)*/ 0u

  , /*decltype(_impl_.congestion_level_)*/ 0

  , /*decltype(_impl_.timestamp_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.occupancy_status_)*/ 0

  , /*decltype(_impl_.occupancy_percentage_)*/ 0u

  , /*decltype(_impl_.current_status_)*/ 2
} {}
struct VehiclePositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VehiclePositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VehiclePositionDefaultTypeInternal() {}
  union {
    VehiclePosition _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VehiclePositionDefaultTypeInternal _VehiclePosition_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Alert::Alert(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.active_period_)*/{}
  , /*decltype(_impl_.informed_entity_)*/{}
  , /*decltype(_impl_.url_)*/nullptr
  , /*decltype(_impl_.header_text_)*/nullptr
  , /*decltype(_impl_.description_text_)*/nullptr
  , /*decltype(_impl_.tts_header_text_)*/nullptr
  , /*decltype(_impl_.tts_description_text_)*/nullptr
  , /*decltype(_impl_.image_)*/nullptr
  , /*decltype(_impl_.image_alternative_text_)*/nullptr
  , /*decltype(_impl_.cause_detail_)*/nullptr
  , /*decltype(_impl_.effect_detail_)*/nullptr
  , /*decltype(_impl_.severity_level_)*/ 1

  , /*decltype(_impl_.cause_)*/ 1

  , /*decltype(_impl_.effect_)*/ 8
} {}
struct AlertDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlertDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlertDefaultTypeInternal() {}
  union {
    Alert _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlertDefaultTypeInternal _Alert_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TimeRange::TimeRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.end_)*/ ::uint64_t{0u}
} {}
struct TimeRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeRangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeRangeDefaultTypeInternal() {}
  union {
    TimeRange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Position::Position(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.latitude_)*/ 0

  , /*decltype(_impl_.longitude_)*/ 0

  , /*decltype(_impl_.odometer_)*/ 0

  , /*decltype(_impl_.bearing_)*/ 0

  , /*decltype(_impl_.speed_)*/ 0
} {}
struct PositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionDefaultTypeInternal _Position_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripDescriptor_ModifiedTripSelector::TripDescriptor_ModifiedTripSelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.modifications_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.affected_trip_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_time_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_date_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct TripDescriptor_ModifiedTripSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripDescriptor_ModifiedTripSelectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripDescriptor_ModifiedTripSelectorDefaultTypeInternal() {}
  union {
    TripDescriptor_ModifiedTripSelector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripDescriptor_ModifiedTripSelectorDefaultTypeInternal _TripDescriptor_ModifiedTripSelector_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripDescriptor::TripDescriptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trip_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_time_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_date_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.route_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.modified_trip_)*/nullptr
  , /*decltype(_impl_.schedule_relationship_)*/ 0

  , /*decltype(_impl_.direction_id_)*/ 0u
} {}
struct TripDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripDescriptorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripDescriptorDefaultTypeInternal() {}
  union {
    TripDescriptor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripDescriptorDefaultTypeInternal _TripDescriptor_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR VehicleDescriptor::VehicleDescriptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.label_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.license_plate_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.wheelchair_accessible_)*/ 0
} {}
struct VehicleDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VehicleDescriptorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VehicleDescriptorDefaultTypeInternal() {}
  union {
    VehicleDescriptor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VehicleDescriptorDefaultTypeInternal _VehicleDescriptor_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR EntitySelector::EntitySelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.agency_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.route_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.stop_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.trip_)*/nullptr
  , /*decltype(_impl_.route_type_)*/ 0

  , /*decltype(_impl_.direction_id_)*/ 0u
} {}
struct EntitySelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntitySelectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntitySelectorDefaultTypeInternal() {}
  union {
    EntitySelector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntitySelectorDefaultTypeInternal _EntitySelector_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TranslatedString_Translation::TranslatedString_Translation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.language_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct TranslatedString_TranslationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranslatedString_TranslationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranslatedString_TranslationDefaultTypeInternal() {}
  union {
    TranslatedString_Translation _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranslatedString_TranslationDefaultTypeInternal _TranslatedString_Translation_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TranslatedString::TranslatedString(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_.translation_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TranslatedStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranslatedStringDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranslatedStringDefaultTypeInternal() {}
  union {
    TranslatedString _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranslatedStringDefaultTypeInternal _TranslatedString_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TranslatedImage_LocalizedImage::TranslatedImage_LocalizedImage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.url_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.media_type_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.language_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct TranslatedImage_LocalizedImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranslatedImage_LocalizedImageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranslatedImage_LocalizedImageDefaultTypeInternal() {}
  union {
    TranslatedImage_LocalizedImage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranslatedImage_LocalizedImageDefaultTypeInternal _TranslatedImage_LocalizedImage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TranslatedImage::TranslatedImage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_.localized_image_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TranslatedImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranslatedImageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranslatedImageDefaultTypeInternal() {}
  union {
    TranslatedImage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranslatedImageDefaultTypeInternal _TranslatedImage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Shape::Shape(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.shape_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.encoded_polyline_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct ShapeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShapeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShapeDefaultTypeInternal() {}
  union {
    Shape _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShapeDefaultTypeInternal _Shape_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR Stop::Stop(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.zone_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.parent_station_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.stop_timezone_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.level_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.stop_code_)*/nullptr
  , /*decltype(_impl_.stop_name_)*/nullptr
  , /*decltype(_impl_.tts_stop_name_)*/nullptr
  , /*decltype(_impl_.stop_desc_)*/nullptr
  , /*decltype(_impl_.stop_url_)*/nullptr
  , /*decltype(_impl_.platform_code_)*/nullptr
  , /*decltype(_impl_.stop_lat_)*/ 0

  , /*decltype(_impl_.stop_lon_)*/ 0

  , /*decltype(_impl_.wheelchair_boarding_)*/ 0
} {}
struct StopDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopDefaultTypeInternal() {}
  union {
    Stop _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopDefaultTypeInternal _Stop_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripModifications_Modification::TripModifications_Modification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.replacement_stops_)*/{}
  , /*decltype(_impl_.service_alert_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.start_stop_selector_)*/nullptr
  , /*decltype(_impl_.end_stop_selector_)*/nullptr
  , /*decltype(_impl_.last_modified_time_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.propagated_modification_delay_)*/ 0
} {}
struct TripModifications_ModificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripModifications_ModificationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripModifications_ModificationDefaultTypeInternal() {}
  union {
    TripModifications_Modification _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripModifications_ModificationDefaultTypeInternal _TripModifications_Modification_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripModifications_SelectedTrips::TripModifications_SelectedTrips(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.trip_ids_)*/{}
  , /*decltype(_impl_.shape_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }
} {}
struct TripModifications_SelectedTripsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripModifications_SelectedTripsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripModifications_SelectedTripsDefaultTypeInternal() {}
  union {
    TripModifications_SelectedTrips _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripModifications_SelectedTripsDefaultTypeInternal _TripModifications_SelectedTrips_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TripModifications::TripModifications(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_.selected_trips_)*/{}
  , /*decltype(_impl_.start_times_)*/{}
  , /*decltype(_impl_.service_dates_)*/{}
  , /*decltype(_impl_.modifications_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TripModificationsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TripModificationsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TripModificationsDefaultTypeInternal() {}
  union {
    TripModifications _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TripModificationsDefaultTypeInternal _TripModifications_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR StopSelector::StopSelector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.stop_sequence_)*/ 0u
} {}
struct StopSelectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StopSelectorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~StopSelectorDefaultTypeInternal() {}
  union {
    StopSelector _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StopSelectorDefaultTypeInternal _StopSelector_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ReplacementStop::ReplacementStop(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._extensions_)*/{}
  , /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.stop_id_)*/ {
    &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {}
  }

  , /*decltype(_impl_.travel_time_to_stop_)*/ 0
} {}
struct ReplacementStopDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReplacementStopDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReplacementStopDefaultTypeInternal() {}
  union {
    ReplacementStop _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplacementStopDefaultTypeInternal _ReplacementStop_default_instance_;
}  // namespace transit_realtime
static ::_pb::Metadata file_level_metadata_gtfs_2drealtime_2eproto[28];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_gtfs_2drealtime_2eproto[11];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_gtfs_2drealtime_2eproto = nullptr;
const ::uint32_t TableStruct_gtfs_2drealtime_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedMessage, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedMessage, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedMessage, _impl_.header_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedMessage, _impl_.entity_),
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedHeader, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedHeader, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedHeader, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedHeader, _impl_.gtfs_realtime_version_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedHeader, _impl_.incrementality_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedHeader, _impl_.timestamp_),
    0,
    2,
    1,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.is_deleted_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.trip_update_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.vehicle_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.alert_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.shape_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.stop_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::FeedEntity, _impl_.trip_modifications_),
    0,
    7,
    1,
    2,
    3,
    4,
    5,
    6,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeEvent, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeEvent, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeEvent, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeEvent, _impl_.delay_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeEvent, _impl_.time_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeEvent, _impl_.uncertainty_),
    1,
    0,
    2,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties, _impl_.assigned_stop_id_),
    0,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_.stop_sequence_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_.stop_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_.arrival_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_.departure_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_.departure_occupancy_status_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_.schedule_relationship_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_StopTimeUpdate, _impl_.stop_time_properties_),
    4,
    0,
    1,
    2,
    6,
    5,
    3,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_TripProperties, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_TripProperties, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_TripProperties, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_TripProperties, _impl_.trip_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_TripProperties, _impl_.start_date_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_TripProperties, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate_TripProperties, _impl_.shape_id_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_.trip_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_.vehicle_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_.stop_time_update_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_.delay_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripUpdate, _impl_.trip_properties_),
    0,
    1,
    ~0u,
    3,
    4,
    2,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _impl_.label_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _impl_.occupancy_status_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _impl_.occupancy_percentage_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition_CarriageDetails, _impl_.carriage_sequence_),
    0,
    1,
    3,
    4,
    2,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.trip_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.vehicle_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.position_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.current_stop_sequence_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.stop_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.current_status_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.timestamp_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.congestion_level_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.occupancy_status_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.occupancy_percentage_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehiclePosition, _impl_.multi_carriage_details_),
    1,
    3,
    2,
    4,
    0,
    9,
    6,
    5,
    7,
    8,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.active_period_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.informed_entity_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.cause_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.effect_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.url_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.header_text_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.description_text_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.tts_header_text_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.tts_description_text_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.severity_level_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.image_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.image_alternative_text_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.cause_detail_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Alert, _impl_.effect_detail_),
    ~0u,
    ~0u,
    10,
    11,
    0,
    1,
    2,
    3,
    4,
    9,
    5,
    6,
    7,
    8,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TimeRange, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TimeRange, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TimeRange, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TimeRange, _impl_.start_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TimeRange, _impl_.end_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _impl_.latitude_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _impl_.longitude_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _impl_.bearing_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _impl_.odometer_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Position, _impl_.speed_),
    0,
    1,
    3,
    2,
    4,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor_ModifiedTripSelector, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor_ModifiedTripSelector, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor_ModifiedTripSelector, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor_ModifiedTripSelector, _impl_.modifications_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor_ModifiedTripSelector, _impl_.affected_trip_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor_ModifiedTripSelector, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor_ModifiedTripSelector, _impl_.start_date_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_.trip_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_.route_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_.direction_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_.start_date_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_.schedule_relationship_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripDescriptor, _impl_.modified_trip_),
    0,
    3,
    6,
    1,
    2,
    5,
    4,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehicleDescriptor, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehicleDescriptor, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehicleDescriptor, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehicleDescriptor, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehicleDescriptor, _impl_.label_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehicleDescriptor, _impl_.license_plate_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::VehicleDescriptor, _impl_.wheelchair_accessible_),
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_.agency_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_.route_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_.route_type_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_.trip_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_.stop_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::EntitySelector, _impl_.direction_id_),
    0,
    1,
    4,
    3,
    2,
    5,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString_Translation, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString_Translation, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString_Translation, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString_Translation, _impl_.text_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString_Translation, _impl_.language_),
    0,
    1,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedString, _impl_.translation_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage_LocalizedImage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage_LocalizedImage, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage_LocalizedImage, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage_LocalizedImage, _impl_.url_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage_LocalizedImage, _impl_.media_type_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage_LocalizedImage, _impl_.language_),
    0,
    1,
    2,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TranslatedImage, _impl_.localized_image_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Shape, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Shape, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Shape, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Shape, _impl_.shape_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Shape, _impl_.encoded_polyline_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_code_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_name_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.tts_stop_name_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_desc_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_lat_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_lon_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.zone_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_url_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.parent_station_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.stop_timezone_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.wheelchair_boarding_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.level_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::Stop, _impl_.platform_code_),
    0,
    5,
    6,
    7,
    8,
    11,
    12,
    1,
    9,
    2,
    3,
    13,
    4,
    10,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_.start_stop_selector_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_.end_stop_selector_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_.propagated_modification_delay_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_.replacement_stops_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_.service_alert_id_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_Modification, _impl_.last_modified_time_),
    1,
    2,
    4,
    ~0u,
    0,
    3,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_SelectedTrips, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_SelectedTrips, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_SelectedTrips, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_SelectedTrips, _impl_.trip_ids_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications_SelectedTrips, _impl_.shape_id_),
    ~0u,
    0,
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications, _impl_.selected_trips_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications, _impl_.start_times_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications, _impl_.service_dates_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::TripModifications, _impl_.modifications_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::StopSelector, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::StopSelector, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::StopSelector, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::StopSelector, _impl_.stop_sequence_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::StopSelector, _impl_.stop_id_),
    1,
    0,
    PROTOBUF_FIELD_OFFSET(::transit_realtime::ReplacementStop, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::ReplacementStop, _internal_metadata_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::ReplacementStop, _impl_._extensions_),
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::transit_realtime::ReplacementStop, _impl_.travel_time_to_stop_),
    PROTOBUF_FIELD_OFFSET(::transit_realtime::ReplacementStop, _impl_.stop_id_),
    1,
    0,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 10, -1, sizeof(::transit_realtime::FeedMessage)},
        { 12, 23, -1, sizeof(::transit_realtime::FeedHeader)},
        { 26, 42, -1, sizeof(::transit_realtime::FeedEntity)},
        { 50, 61, -1, sizeof(::transit_realtime::TripUpdate_StopTimeEvent)},
        { 64, 73, -1, sizeof(::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties)},
        { 74, 89, -1, sizeof(::transit_realtime::TripUpdate_StopTimeUpdate)},
        { 96, 108, -1, sizeof(::transit_realtime::TripUpdate_TripProperties)},
        { 112, 126, -1, sizeof(::transit_realtime::TripUpdate)},
        { 132, 145, -1, sizeof(::transit_realtime::VehiclePosition_CarriageDetails)},
        { 150, 169, -1, sizeof(::transit_realtime::VehiclePosition)},
        { 180, 202, -1, sizeof(::transit_realtime::Alert)},
        { 216, 226, -1, sizeof(::transit_realtime::TimeRange)},
        { 228, 241, -1, sizeof(::transit_realtime::Position)},
        { 246, 258, -1, sizeof(::transit_realtime::TripDescriptor_ModifiedTripSelector)},
        { 262, 277, -1, sizeof(::transit_realtime::TripDescriptor)},
        { 284, 296, -1, sizeof(::transit_realtime::VehicleDescriptor)},
        { 300, 314, -1, sizeof(::transit_realtime::EntitySelector)},
        { 320, 330, -1, sizeof(::transit_realtime::TranslatedString_Translation)},
        { 332, -1, -1, sizeof(::transit_realtime::TranslatedString)},
        { 341, 352, -1, sizeof(::transit_realtime::TranslatedImage_LocalizedImage)},
        { 355, -1, -1, sizeof(::transit_realtime::TranslatedImage)},
        { 364, 374, -1, sizeof(::transit_realtime::Shape)},
        { 376, 398, -1, sizeof(::transit_realtime::Stop)},
        { 412, 426, -1, sizeof(::transit_realtime::TripModifications_Modification)},
        { 432, 442, -1, sizeof(::transit_realtime::TripModifications_SelectedTrips)},
        { 444, -1, -1, sizeof(::transit_realtime::TripModifications)},
        { 456, 466, -1, sizeof(::transit_realtime::StopSelector)},
        { 468, 478, -1, sizeof(::transit_realtime::ReplacementStop)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::transit_realtime::_FeedMessage_default_instance_._instance,
    &::transit_realtime::_FeedHeader_default_instance_._instance,
    &::transit_realtime::_FeedEntity_default_instance_._instance,
    &::transit_realtime::_TripUpdate_StopTimeEvent_default_instance_._instance,
    &::transit_realtime::_TripUpdate_StopTimeUpdate_StopTimeProperties_default_instance_._instance,
    &::transit_realtime::_TripUpdate_StopTimeUpdate_default_instance_._instance,
    &::transit_realtime::_TripUpdate_TripProperties_default_instance_._instance,
    &::transit_realtime::_TripUpdate_default_instance_._instance,
    &::transit_realtime::_VehiclePosition_CarriageDetails_default_instance_._instance,
    &::transit_realtime::_VehiclePosition_default_instance_._instance,
    &::transit_realtime::_Alert_default_instance_._instance,
    &::transit_realtime::_TimeRange_default_instance_._instance,
    &::transit_realtime::_Position_default_instance_._instance,
    &::transit_realtime::_TripDescriptor_ModifiedTripSelector_default_instance_._instance,
    &::transit_realtime::_TripDescriptor_default_instance_._instance,
    &::transit_realtime::_VehicleDescriptor_default_instance_._instance,
    &::transit_realtime::_EntitySelector_default_instance_._instance,
    &::transit_realtime::_TranslatedString_Translation_default_instance_._instance,
    &::transit_realtime::_TranslatedString_default_instance_._instance,
    &::transit_realtime::_TranslatedImage_LocalizedImage_default_instance_._instance,
    &::transit_realtime::_TranslatedImage_default_instance_._instance,
    &::transit_realtime::_Shape_default_instance_._instance,
    &::transit_realtime::_Stop_default_instance_._instance,
    &::transit_realtime::_TripModifications_Modification_default_instance_._instance,
    &::transit_realtime::_TripModifications_SelectedTrips_default_instance_._instance,
    &::transit_realtime::_TripModifications_default_instance_._instance,
    &::transit_realtime::_StopSelector_default_instance_._instance,
    &::transit_realtime::_ReplacementStop_default_instance_._instance,
};
const char descriptor_table_protodef_gtfs_2drealtime_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\023gtfs-realtime.proto\022\020transit_realtime\""
    "y\n\013FeedMessage\022,\n\006header\030\001 \002(\0132\034.transit"
    "_realtime.FeedHeader\022,\n\006entity\030\002 \003(\0132\034.t"
    "ransit_realtime.FeedEntity*\006\010\350\007\020\320\017*\006\010\250F\020"
    "\220N\"\327\001\n\nFeedHeader\022\035\n\025gtfs_realtime_versi"
    "on\030\001 \002(\t\022Q\n\016incrementality\030\002 \001(\0162+.trans"
    "it_realtime.FeedHeader.Incrementality:\014F"
    "ULL_DATASET\022\021\n\ttimestamp\030\003 \001(\004\"4\n\016Increm"
    "entality\022\020\n\014FULL_DATASET\020\000\022\020\n\014DIFFERENTI"
    "AL\020\001*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\341\002\n\nFeedEntity\022\n\n\002i"
    "d\030\001 \002(\t\022\031\n\nis_deleted\030\002 \001(\010:\005false\0221\n\013tr"
    "ip_update\030\003 \001(\0132\034.transit_realtime.TripU"
    "pdate\0222\n\007vehicle\030\004 \001(\0132!.transit_realtim"
    "e.VehiclePosition\022&\n\005alert\030\005 \001(\0132\027.trans"
    "it_realtime.Alert\022&\n\005shape\030\006 \001(\0132\027.trans"
    "it_realtime.Shape\022$\n\004stop\030\007 \001(\0132\026.transi"
    "t_realtime.Stop\022\?\n\022trip_modifications\030\010 "
    "\001(\0132#.transit_realtime.TripModifications"
    "*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\353\010\n\nTripUpdate\022.\n\004trip\030"
    "\001 \002(\0132 .transit_realtime.TripDescriptor\022"
    "4\n\007vehicle\030\003 \001(\0132#.transit_realtime.Vehi"
    "cleDescriptor\022E\n\020stop_time_update\030\002 \003(\0132"
    "+.transit_realtime.TripUpdate.StopTimeUp"
    "date\022\021\n\ttimestamp\030\004 \001(\004\022\r\n\005delay\030\005 \001(\005\022D"
    "\n\017trip_properties\030\006 \001(\0132+.transit_realti"
    "me.TripUpdate.TripProperties\032Q\n\rStopTime"
    "Event\022\r\n\005delay\030\001 \001(\005\022\014\n\004time\030\002 \001(\003\022\023\n\013un"
    "certainty\030\003 \001(\005*\006\010\350\007\020\320\017*\006\010\250F\020\220N\032\367\004\n\016Stop"
    "TimeUpdate\022\025\n\rstop_sequence\030\001 \001(\r\022\017\n\007sto"
    "p_id\030\004 \001(\t\022;\n\007arrival\030\002 \001(\0132*.transit_re"
    "altime.TripUpdate.StopTimeEvent\022=\n\tdepar"
    "ture\030\003 \001(\0132*.transit_realtime.TripUpdate"
    ".StopTimeEvent\022U\n\032departure_occupancy_st"
    "atus\030\007 \001(\01621.transit_realtime.VehiclePos"
    "ition.OccupancyStatus\022j\n\025schedule_relati"
    "onship\030\005 \001(\0162@.transit_realtime.TripUpda"
    "te.StopTimeUpdate.ScheduleRelationship:\t"
    "SCHEDULED\022\\\n\024stop_time_properties\030\006 \001(\0132"
    ">.transit_realtime.TripUpdate.StopTimeUp"
    "date.StopTimeProperties\032>\n\022StopTimePrope"
    "rties\022\030\n\020assigned_stop_id\030\001 \001(\t*\006\010\350\007\020\320\017*"
    "\006\010\250F\020\220N\"P\n\024ScheduleRelationship\022\r\n\tSCHED"
    "ULED\020\000\022\013\n\007SKIPPED\020\001\022\013\n\007NO_DATA\020\002\022\017\n\013UNSC"
    "HEDULED\020\003*\006\010\350\007\020\320\017*\006\010\250F\020\220N\032k\n\016TripPropert"
    "ies\022\017\n\007trip_id\030\001 \001(\t\022\022\n\nstart_date\030\002 \001(\t"
    "\022\022\n\nstart_time\030\003 \001(\t\022\020\n\010shape_id\030\004 \001(\t*\006"
    "\010\350\007\020\320\017*\006\010\250F\020\220N*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\337\t\n\017Vehic"
    "lePosition\022.\n\004trip\030\001 \001(\0132 .transit_realt"
    "ime.TripDescriptor\0224\n\007vehicle\030\010 \001(\0132#.tr"
    "ansit_realtime.VehicleDescriptor\022,\n\010posi"
    "tion\030\002 \001(\0132\032.transit_realtime.Position\022\035"
    "\n\025current_stop_sequence\030\003 \001(\r\022\017\n\007stop_id"
    "\030\007 \001(\t\022Z\n\016current_status\030\004 \001(\01623.transit"
    "_realtime.VehiclePosition.VehicleStopSta"
    "tus:\rIN_TRANSIT_TO\022\021\n\ttimestamp\030\005 \001(\004\022K\n"
    "\020congestion_level\030\006 \001(\01621.transit_realti"
    "me.VehiclePosition.CongestionLevel\022K\n\020oc"
    "cupancy_status\030\t \001(\01621.transit_realtime."
    "VehiclePosition.OccupancyStatus\022\034\n\024occup"
    "ancy_percentage\030\n \001(\r\022Q\n\026multi_carriage_"
    "details\030\013 \003(\01321.transit_realtime.Vehicle"
    "Position.CarriageDetails\032\331\001\n\017CarriageDet"
    "ails\022\n\n\002id\030\001 \001(\t\022\r\n\005label\030\002 \001(\t\022^\n\020occup"
    "ancy_status\030\003 \001(\01621.transit_realtime.Veh"
    "iclePosition.OccupancyStatus:\021NO_DATA_AV"
    "AILABLE\022 \n\024occupancy_percentage\030\004 \001(\005:\002-"
    "1\022\031\n\021carriage_sequence\030\005 \001(\r*\006\010\350\007\020\320\017*\006\010\250"
    "F\020\220N\"G\n\021VehicleStopStatus\022\017\n\013INCOMING_AT"
    "\020\000\022\016\n\nSTOPPED_AT\020\001\022\021\n\rIN_TRANSIT_TO\020\002\"}\n"
    "\017CongestionLevel\022\034\n\030UNKNOWN_CONGESTION_L"
    "EVEL\020\000\022\024\n\020RUNNING_SMOOTHLY\020\001\022\017\n\013STOP_AND"
    "_GO\020\002\022\016\n\nCONGESTION\020\003\022\025\n\021SEVERE_CONGESTI"
    "ON\020\004\"\331\001\n\017OccupancyStatus\022\t\n\005EMPTY\020\000\022\030\n\024M"
    "ANY_SEATS_AVAILABLE\020\001\022\027\n\023FEW_SEATS_AVAIL"
    "ABLE\020\002\022\026\n\022STANDING_ROOM_ONLY\020\003\022\036\n\032CRUSHE"
    "D_STANDING_ROOM_ONLY\020\004\022\010\n\004FULL\020\005\022\034\n\030NOT_"
    "ACCEPTING_PASSENGERS\020\006\022\025\n\021NO_DATA_AVAILA"
    "BLE\020\007\022\021\n\rNOT_BOARDABLE\020\010*\006\010\350\007\020\320\017*\006\010\250F\020\220N"
    "\"\353\n\n\005Alert\0222\n\ractive_period\030\001 \003(\0132\033.tran"
    "sit_realtime.TimeRange\0229\n\017informed_entit"
    "y\030\005 \003(\0132 .transit_realtime.EntitySelecto"
    "r\022;\n\005cause\030\006 \001(\0162\035.transit_realtime.Aler"
    "t.Cause:\rUNKNOWN_CAUSE\022>\n\006effect\030\007 \001(\0162\036"
    ".transit_realtime.Alert.Effect:\016UNKNOWN_"
    "EFFECT\022/\n\003url\030\010 \001(\0132\".transit_realtime.T"
    "ranslatedString\0227\n\013header_text\030\n \001(\0132\".t"
    "ransit_realtime.TranslatedString\022<\n\020desc"
    "ription_text\030\013 \001(\0132\".transit_realtime.Tr"
    "anslatedString\022;\n\017tts_header_text\030\014 \001(\0132"
    "\".transit_realtime.TranslatedString\022@\n\024t"
    "ts_description_text\030\r \001(\0132\".transit_real"
    "time.TranslatedString\022O\n\016severity_level\030"
    "\016 \001(\0162%.transit_realtime.Alert.SeverityL"
    "evel:\020UNKNOWN_SEVERITY\0220\n\005image\030\017 \001(\0132!."
    "transit_realtime.TranslatedImage\022B\n\026imag"
    "e_alternative_text\030\020 \001(\0132\".transit_realt"
    "ime.TranslatedString\0228\n\014cause_detail\030\021 \001"
    "(\0132\".transit_realtime.TranslatedString\0229"
    "\n\reffect_detail\030\022 \001(\0132\".transit_realtime"
    ".TranslatedString\"\330\001\n\005Cause\022\021\n\rUNKNOWN_C"
    "AUSE\020\001\022\017\n\013OTHER_CAUSE\020\002\022\025\n\021TECHNICAL_PRO"
    "BLEM\020\003\022\n\n\006STRIKE\020\004\022\021\n\rDEMONSTRATION\020\005\022\014\n"
    "\010ACCIDENT\020\006\022\013\n\007HOLIDAY\020\007\022\013\n\007WEATHER\020\010\022\017\n"
    "\013MAINTENANCE\020\t\022\020\n\014CONSTRUCTION\020\n\022\023\n\017POLI"
    "CE_ACTIVITY\020\013\022\025\n\021MEDICAL_EMERGENCY\020\014\"\335\001\n"
    "\006Effect\022\016\n\nNO_SERVICE\020\001\022\023\n\017REDUCED_SERVI"
    "CE\020\002\022\026\n\022SIGNIFICANT_DELAYS\020\003\022\n\n\006DETOUR\020\004"
    "\022\026\n\022ADDITIONAL_SERVICE\020\005\022\024\n\020MODIFIED_SER"
    "VICE\020\006\022\020\n\014OTHER_EFFECT\020\007\022\022\n\016UNKNOWN_EFFE"
    "CT\020\010\022\016\n\nSTOP_MOVED\020\t\022\r\n\tNO_EFFECT\020\n\022\027\n\023A"
    "CCESSIBILITY_ISSUE\020\013\"H\n\rSeverityLevel\022\024\n"
    "\020UNKNOWN_SEVERITY\020\001\022\010\n\004INFO\020\002\022\013\n\007WARNING"
    "\020\003\022\n\n\006SEVERE\020\004*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"7\n\tTimeRa"
    "nge\022\r\n\005start\030\001 \001(\004\022\013\n\003end\030\002 \001(\004*\006\010\350\007\020\320\017*"
    "\006\010\250F\020\220N\"q\n\010Position\022\020\n\010latitude\030\001 \002(\002\022\021\n"
    "\tlongitude\030\002 \002(\002\022\017\n\007bearing\030\003 \001(\002\022\020\n\010odo"
    "meter\030\004 \001(\001\022\r\n\005speed\030\005 \001(\002*\006\010\350\007\020\320\017*\006\010\250F\020"
    "\220N\"\256\004\n\016TripDescriptor\022\017\n\007trip_id\030\001 \001(\t\022\020"
    "\n\010route_id\030\005 \001(\t\022\024\n\014direction_id\030\006 \001(\r\022\022"
    "\n\nstart_time\030\002 \001(\t\022\022\n\nstart_date\030\003 \001(\t\022T"
    "\n\025schedule_relationship\030\004 \001(\01625.transit_"
    "realtime.TripDescriptor.ScheduleRelation"
    "ship\022L\n\rmodified_trip\030\007 \001(\01325.transit_re"
    "altime.TripDescriptor.ModifiedTripSelect"
    "or\032\202\001\n\024ModifiedTripSelector\022\030\n\020modificat"
    "ions_id\030\001 \001(\t\022\030\n\020affected_trip_id\030\002 \001(\t\022"
    "\022\n\nstart_time\030\003 \001(\t\022\022\n\nstart_date\030\004 \001(\t*"
    "\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\201\001\n\024ScheduleRelationship"
    "\022\r\n\tSCHEDULED\020\000\022\t\n\005ADDED\020\001\022\017\n\013UNSCHEDULE"
    "D\020\002\022\014\n\010CANCELED\020\003\022\023\n\013REPLACEMENT\020\005\032\002\010\001\022\016"
    "\n\nDUPLICATED\020\006\022\013\n\007DELETED\020\007*\006\010\350\007\020\320\017*\006\010\250F"
    "\020\220N\"\243\002\n\021VehicleDescriptor\022\n\n\002id\030\001 \001(\t\022\r\n"
    "\005label\030\002 \001(\t\022\025\n\rlicense_plate\030\003 \001(\t\022a\n\025w"
    "heelchair_accessible\030\004 \001(\01628.transit_rea"
    "ltime.VehicleDescriptor.WheelchairAccess"
    "ible:\010NO_VALUE\"i\n\024WheelchairAccessible\022\014"
    "\n\010NO_VALUE\020\000\022\013\n\007UNKNOWN\020\001\022\031\n\025WHEELCHAIR_"
    "ACCESSIBLE\020\002\022\033\n\027WHEELCHAIR_INACCESSIBLE\020"
    "\003*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\260\001\n\016EntitySelector\022\021\n\t"
    "agency_id\030\001 \001(\t\022\020\n\010route_id\030\002 \001(\t\022\022\n\nrou"
    "te_type\030\003 \001(\005\022.\n\004trip\030\004 \001(\0132 .transit_re"
    "altime.TripDescriptor\022\017\n\007stop_id\030\005 \001(\t\022\024"
    "\n\014direction_id\030\006 \001(\r*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\246\001\n"
    "\020TranslatedString\022C\n\013translation\030\001 \003(\0132."
    ".transit_realtime.TranslatedString.Trans"
    "lation\032=\n\013Translation\022\014\n\004text\030\001 \002(\t\022\020\n\010l"
    "anguage\030\002 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N*\006\010\350\007\020\320\017*\006\010"
    "\250F\020\220N\"\301\001\n\017TranslatedImage\022I\n\017localized_i"
    "mage\030\001 \003(\01320.transit_realtime.Translated"
    "Image.LocalizedImage\032S\n\016LocalizedImage\022\013"
    "\n\003url\030\001 \002(\t\022\022\n\nmedia_type\030\002 \002(\t\022\020\n\010langu"
    "age\030\003 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N*\006\010\350\007\020\320\017*\006\010\250F\020\220"
    "N\"C\n\005Shape\022\020\n\010shape_id\030\001 \001(\t\022\030\n\020encoded_"
    "polyline\030\002 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\204\005\n\004Stop\022"
    "\017\n\007stop_id\030\001 \001(\t\0225\n\tstop_code\030\002 \001(\0132\".tr"
    "ansit_realtime.TranslatedString\0225\n\tstop_"
    "name\030\003 \001(\0132\".transit_realtime.Translated"
    "String\0229\n\rtts_stop_name\030\004 \001(\0132\".transit_"
    "realtime.TranslatedString\0225\n\tstop_desc\030\005"
    " \001(\0132\".transit_realtime.TranslatedString"
    "\022\020\n\010stop_lat\030\006 \001(\002\022\020\n\010stop_lon\030\007 \001(\002\022\017\n\007"
    "zone_id\030\010 \001(\t\0224\n\010stop_url\030\t \001(\0132\".transi"
    "t_realtime.TranslatedString\022\026\n\016parent_st"
    "ation\030\013 \001(\t\022\025\n\rstop_timezone\030\014 \001(\t\022O\n\023wh"
    "eelchair_boarding\030\r \001(\0162).transit_realti"
    "me.Stop.WheelchairBoarding:\007UNKNOWN\022\020\n\010l"
    "evel_id\030\016 \001(\t\0229\n\rplatform_code\030\017 \001(\0132\".t"
    "ransit_realtime.TranslatedString\"C\n\022Whee"
    "lchairBoarding\022\013\n\007UNKNOWN\020\000\022\r\n\tAVAILABLE"
    "\020\001\022\021\n\rNOT_AVAILABLE\020\002*\006\010\350\007\020\320\017*\006\010\250F\020\220N\"\337\004"
    "\n\021TripModifications\022I\n\016selected_trips\030\001 "
    "\003(\01321.transit_realtime.TripModifications"
    ".SelectedTrips\022\023\n\013start_times\030\002 \003(\t\022\025\n\rs"
    "ervice_dates\030\003 \003(\t\022G\n\rmodifications\030\004 \003("
    "\01320.transit_realtime.TripModifications.M"
    "odification\032\264\002\n\014Modification\022;\n\023start_st"
    "op_selector\030\001 \001(\0132\036.transit_realtime.Sto"
    "pSelector\0229\n\021end_stop_selector\030\002 \001(\0132\036.t"
    "ransit_realtime.StopSelector\022(\n\035propagat"
    "ed_modification_delay\030\003 \001(\005:\0010\022<\n\021replac"
    "ement_stops\030\004 \003(\0132!.transit_realtime.Rep"
    "lacementStop\022\030\n\020service_alert_id\030\005 \001(\t\022\032"
    "\n\022last_modified_time\030\006 \001(\004*\006\010\350\007\020\320\017*\006\010\250F\020"
    "\220N\032C\n\rSelectedTrips\022\020\n\010trip_ids\030\001 \003(\t\022\020\n"
    "\010shape_id\030\002 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N*\006\010\350\007\020\320\017*"
    "\006\010\250F\020\220N\"F\n\014StopSelector\022\025\n\rstop_sequence"
    "\030\001 \001(\r\022\017\n\007stop_id\030\002 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N\""
    "O\n\017ReplacementStop\022\033\n\023travel_time_to_sto"
    "p\030\001 \001(\005\022\017\n\007stop_id\030\002 \001(\t*\006\010\350\007\020\320\017*\006\010\250F\020\220N"
    "B\035\n\033com.google.transit.realtime"
};
static ::absl::once_flag descriptor_table_gtfs_2drealtime_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_gtfs_2drealtime_2eproto = {
    false,
    false,
    7591,
    descriptor_table_protodef_gtfs_2drealtime_2eproto,
    "gtfs-realtime.proto",
    &descriptor_table_gtfs_2drealtime_2eproto_once,
    nullptr,
    0,
    28,
    schemas,
    file_default_instances,
    TableStruct_gtfs_2drealtime_2eproto::offsets,
    file_level_metadata_gtfs_2drealtime_2eproto,
    file_level_enum_descriptors_gtfs_2drealtime_2eproto,
    file_level_service_descriptors_gtfs_2drealtime_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_gtfs_2drealtime_2eproto_getter() {
  return &descriptor_table_gtfs_2drealtime_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_gtfs_2drealtime_2eproto(&descriptor_table_gtfs_2drealtime_2eproto);
namespace transit_realtime {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FeedHeader_Incrementality_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[0];
}
bool FeedHeader_Incrementality_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr FeedHeader_Incrementality FeedHeader::FULL_DATASET;
constexpr FeedHeader_Incrementality FeedHeader::DIFFERENTIAL;
constexpr FeedHeader_Incrementality FeedHeader::Incrementality_MIN;
constexpr FeedHeader_Incrementality FeedHeader::Incrementality_MAX;
constexpr int FeedHeader::Incrementality_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[1];
}
bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::SCHEDULED;
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::SKIPPED;
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::NO_DATA;
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::UNSCHEDULED;
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::ScheduleRelationship_MIN;
constexpr TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::ScheduleRelationship_MAX;
constexpr int TripUpdate_StopTimeUpdate::ScheduleRelationship_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_VehicleStopStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[2];
}
bool VehiclePosition_VehicleStopStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VehiclePosition_VehicleStopStatus VehiclePosition::INCOMING_AT;
constexpr VehiclePosition_VehicleStopStatus VehiclePosition::STOPPED_AT;
constexpr VehiclePosition_VehicleStopStatus VehiclePosition::IN_TRANSIT_TO;
constexpr VehiclePosition_VehicleStopStatus VehiclePosition::VehicleStopStatus_MIN;
constexpr VehiclePosition_VehicleStopStatus VehiclePosition::VehicleStopStatus_MAX;
constexpr int VehiclePosition::VehicleStopStatus_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_CongestionLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[3];
}
bool VehiclePosition_CongestionLevel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VehiclePosition_CongestionLevel VehiclePosition::UNKNOWN_CONGESTION_LEVEL;
constexpr VehiclePosition_CongestionLevel VehiclePosition::RUNNING_SMOOTHLY;
constexpr VehiclePosition_CongestionLevel VehiclePosition::STOP_AND_GO;
constexpr VehiclePosition_CongestionLevel VehiclePosition::CONGESTION;
constexpr VehiclePosition_CongestionLevel VehiclePosition::SEVERE_CONGESTION;
constexpr VehiclePosition_CongestionLevel VehiclePosition::CongestionLevel_MIN;
constexpr VehiclePosition_CongestionLevel VehiclePosition::CongestionLevel_MAX;
constexpr int VehiclePosition::CongestionLevel_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehiclePosition_OccupancyStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[4];
}
bool VehiclePosition_OccupancyStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VehiclePosition_OccupancyStatus VehiclePosition::EMPTY;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::MANY_SEATS_AVAILABLE;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::FEW_SEATS_AVAILABLE;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::STANDING_ROOM_ONLY;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::CRUSHED_STANDING_ROOM_ONLY;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::FULL;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::NOT_ACCEPTING_PASSENGERS;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::NO_DATA_AVAILABLE;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::NOT_BOARDABLE;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::OccupancyStatus_MIN;
constexpr VehiclePosition_OccupancyStatus VehiclePosition::OccupancyStatus_MAX;
constexpr int VehiclePosition::OccupancyStatus_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_Cause_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[5];
}
bool Alert_Cause_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Alert_Cause Alert::UNKNOWN_CAUSE;
constexpr Alert_Cause Alert::OTHER_CAUSE;
constexpr Alert_Cause Alert::TECHNICAL_PROBLEM;
constexpr Alert_Cause Alert::STRIKE;
constexpr Alert_Cause Alert::DEMONSTRATION;
constexpr Alert_Cause Alert::ACCIDENT;
constexpr Alert_Cause Alert::HOLIDAY;
constexpr Alert_Cause Alert::WEATHER;
constexpr Alert_Cause Alert::MAINTENANCE;
constexpr Alert_Cause Alert::CONSTRUCTION;
constexpr Alert_Cause Alert::POLICE_ACTIVITY;
constexpr Alert_Cause Alert::MEDICAL_EMERGENCY;
constexpr Alert_Cause Alert::Cause_MIN;
constexpr Alert_Cause Alert::Cause_MAX;
constexpr int Alert::Cause_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_Effect_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[6];
}
bool Alert_Effect_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Alert_Effect Alert::NO_SERVICE;
constexpr Alert_Effect Alert::REDUCED_SERVICE;
constexpr Alert_Effect Alert::SIGNIFICANT_DELAYS;
constexpr Alert_Effect Alert::DETOUR;
constexpr Alert_Effect Alert::ADDITIONAL_SERVICE;
constexpr Alert_Effect Alert::MODIFIED_SERVICE;
constexpr Alert_Effect Alert::OTHER_EFFECT;
constexpr Alert_Effect Alert::UNKNOWN_EFFECT;
constexpr Alert_Effect Alert::STOP_MOVED;
constexpr Alert_Effect Alert::NO_EFFECT;
constexpr Alert_Effect Alert::ACCESSIBILITY_ISSUE;
constexpr Alert_Effect Alert::Effect_MIN;
constexpr Alert_Effect Alert::Effect_MAX;
constexpr int Alert::Effect_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Alert_SeverityLevel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[7];
}
bool Alert_SeverityLevel_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Alert_SeverityLevel Alert::UNKNOWN_SEVERITY;
constexpr Alert_SeverityLevel Alert::INFO;
constexpr Alert_SeverityLevel Alert::WARNING;
constexpr Alert_SeverityLevel Alert::SEVERE;
constexpr Alert_SeverityLevel Alert::SeverityLevel_MIN;
constexpr Alert_SeverityLevel Alert::SeverityLevel_MAX;
constexpr int Alert::SeverityLevel_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TripDescriptor_ScheduleRelationship_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[8];
}
bool TripDescriptor_ScheduleRelationship_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr TripDescriptor_ScheduleRelationship TripDescriptor::SCHEDULED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::ADDED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::UNSCHEDULED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::CANCELED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::REPLACEMENT;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::DUPLICATED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::DELETED;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::ScheduleRelationship_MIN;
constexpr TripDescriptor_ScheduleRelationship TripDescriptor::ScheduleRelationship_MAX;
constexpr int TripDescriptor::ScheduleRelationship_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VehicleDescriptor_WheelchairAccessible_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[9];
}
bool VehicleDescriptor_WheelchairAccessible_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor::NO_VALUE;
constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor::UNKNOWN;
constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor::WHEELCHAIR_ACCESSIBLE;
constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor::WHEELCHAIR_INACCESSIBLE;
constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor::WheelchairAccessible_MIN;
constexpr VehicleDescriptor_WheelchairAccessible VehicleDescriptor::WheelchairAccessible_MAX;
constexpr int VehicleDescriptor::WheelchairAccessible_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Stop_WheelchairBoarding_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gtfs_2drealtime_2eproto);
  return file_level_enum_descriptors_gtfs_2drealtime_2eproto[10];
}
bool Stop_WheelchairBoarding_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr Stop_WheelchairBoarding Stop::UNKNOWN;
constexpr Stop_WheelchairBoarding Stop::AVAILABLE;
constexpr Stop_WheelchairBoarding Stop::NOT_AVAILABLE;
constexpr Stop_WheelchairBoarding Stop::WheelchairBoarding_MIN;
constexpr Stop_WheelchairBoarding Stop::WheelchairBoarding_MAX;
constexpr int Stop::WheelchairBoarding_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class FeedMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<FeedMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FeedMessage, _impl_._has_bits_);
  static const ::transit_realtime::FeedHeader& header(const FeedMessage* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::transit_realtime::FeedHeader&
FeedMessage::_Internal::header(const FeedMessage* msg) {
  return *msg->_impl_.header_;
}
FeedMessage::FeedMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.FeedMessage)
}
FeedMessage::FeedMessage(const FeedMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeedMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_){from._impl_.entity_}
    , decltype(_impl_.header_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.header_ = new ::transit_realtime::FeedHeader(*from._impl_.header_);
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.FeedMessage)
}

inline void FeedMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_){arena}
    , decltype(_impl_.header_){nullptr}
  };
}

FeedMessage::~FeedMessage() {
  // @@protoc_insertion_point(destructor:transit_realtime.FeedMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeedMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_entity()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.header_;
}

void FeedMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeedMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.FeedMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_entity()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.header_ != nullptr);
    _impl_.header_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeedMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .transit_realtime.FeedHeader header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .transit_realtime.FeedEntity entity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeedMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.FeedMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .transit_realtime.FeedHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::header(this),
        _Internal::header(this).GetCachedSize(), target, stream);
  }

  // repeated .transit_realtime.FeedEntity entity = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entity_size()); i < n; i++) {
    const auto& repfield = this->_internal_entity(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.FeedMessage)
  return target;
}

::size_t FeedMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.FeedMessage)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required .transit_realtime.FeedHeader header = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.header_);
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.FeedEntity entity = 2;
  total_size += 1UL * this->_internal_entity_size();
  for (const auto& msg : this->_internal_entity()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeedMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeedMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeedMessage::GetClassData() const { return &_class_data_; }


void FeedMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeedMessage*>(&to_msg);
  auto& from = static_cast<const FeedMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.FeedMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_entity()->MergeFrom(from._internal_entity());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_mutable_header()->::transit_realtime::FeedHeader::MergeFrom(
        from._internal_header());
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeedMessage::CopyFrom(const FeedMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.FeedMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeedMessage::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_entity()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.header_->IsInitialized()) return false;
  }
  return true;
}

void FeedMessage::InternalSwap(FeedMessage* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_entity()->InternalSwap(other->_internal_mutable_entity());
  swap(_impl_.header_, other->_impl_.header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FeedMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[0]);
}
// ===================================================================

class FeedHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<FeedHeader>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FeedHeader, _impl_._has_bits_);
  static void set_has_gtfs_realtime_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_incrementality(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

FeedHeader::FeedHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.FeedHeader)
}
FeedHeader::FeedHeader(const FeedHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeedHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gtfs_realtime_version_) {}

    , decltype(_impl_.timestamp_) {}

    , decltype(_impl_.incrementality_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.gtfs_realtime_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.gtfs_realtime_version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.gtfs_realtime_version_.Set(from._internal_gtfs_realtime_version(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.incrementality_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.incrementality_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.FeedHeader)
}

inline void FeedHeader::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.gtfs_realtime_version_) {}

    , decltype(_impl_.timestamp_) { ::uint64_t{0u} }

    , decltype(_impl_.incrementality_) { 0 }

  };
  _impl_.gtfs_realtime_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.gtfs_realtime_version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FeedHeader::~FeedHeader() {
  // @@protoc_insertion_point(destructor:transit_realtime.FeedHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeedHeader::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.gtfs_realtime_version_.Destroy();
}

void FeedHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeedHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.FeedHeader)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.gtfs_realtime_version_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.incrementality_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.incrementality_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeedHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string gtfs_realtime_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gtfs_realtime_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.FeedHeader.gtfs_realtime_version");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::FeedHeader_Incrementality_IsValid(static_cast<int>(val)))) {
            _internal_set_incrementality(static_cast<::transit_realtime::FeedHeader_Incrementality>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 timestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeedHeader::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.FeedHeader)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string gtfs_realtime_version = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_gtfs_realtime_version();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.FeedHeader.gtfs_realtime_version");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        2, this->_internal_incrementality(), target);
  }

  // optional uint64 timestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        3, this->_internal_timestamp(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.FeedHeader)
  return target;
}

::size_t FeedHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.FeedHeader)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required string gtfs_realtime_version = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_gtfs_realtime_version());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 timestamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_timestamp());
    }

    // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_incrementality());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeedHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeedHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeedHeader::GetClassData() const { return &_class_data_; }


void FeedHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeedHeader*>(&to_msg);
  auto& from = static_cast<const FeedHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.FeedHeader)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_gtfs_realtime_version(from._internal_gtfs_realtime_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.incrementality_ = from._impl_.incrementality_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeedHeader::CopyFrom(const FeedHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.FeedHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeedHeader::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void FeedHeader::InternalSwap(FeedHeader* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.gtfs_realtime_version_, lhs_arena,
                                       &other->_impl_.gtfs_realtime_version_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeedHeader, _impl_.incrementality_)
      + sizeof(FeedHeader::_impl_.incrementality_)
      - PROTOBUF_FIELD_OFFSET(FeedHeader, _impl_.timestamp_)>(
          reinterpret_cast<char*>(&_impl_.timestamp_),
          reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeedHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[1]);
}
// ===================================================================

class FeedEntity::_Internal {
 public:
  using HasBits = decltype(std::declval<FeedEntity>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(FeedEntity, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_deleted(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::transit_realtime::TripUpdate& trip_update(const FeedEntity* msg);
  static void set_has_trip_update(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::transit_realtime::VehiclePosition& vehicle(const FeedEntity* msg);
  static void set_has_vehicle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::transit_realtime::Alert& alert(const FeedEntity* msg);
  static void set_has_alert(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::transit_realtime::Shape& shape(const FeedEntity* msg);
  static void set_has_shape(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::transit_realtime::Stop& stop(const FeedEntity* msg);
  static void set_has_stop(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::transit_realtime::TripModifications& trip_modifications(const FeedEntity* msg);
  static void set_has_trip_modifications(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::transit_realtime::TripUpdate&
FeedEntity::_Internal::trip_update(const FeedEntity* msg) {
  return *msg->_impl_.trip_update_;
}
const ::transit_realtime::VehiclePosition&
FeedEntity::_Internal::vehicle(const FeedEntity* msg) {
  return *msg->_impl_.vehicle_;
}
const ::transit_realtime::Alert&
FeedEntity::_Internal::alert(const FeedEntity* msg) {
  return *msg->_impl_.alert_;
}
const ::transit_realtime::Shape&
FeedEntity::_Internal::shape(const FeedEntity* msg) {
  return *msg->_impl_.shape_;
}
const ::transit_realtime::Stop&
FeedEntity::_Internal::stop(const FeedEntity* msg) {
  return *msg->_impl_.stop_;
}
const ::transit_realtime::TripModifications&
FeedEntity::_Internal::trip_modifications(const FeedEntity* msg) {
  return *msg->_impl_.trip_modifications_;
}
FeedEntity::FeedEntity(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.FeedEntity)
}
FeedEntity::FeedEntity(const FeedEntity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FeedEntity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.trip_update_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.alert_){nullptr}
    , decltype(_impl_.shape_){nullptr}
    , decltype(_impl_.stop_){nullptr}
    , decltype(_impl_.trip_modifications_){nullptr}
    , decltype(_impl_.is_deleted_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.trip_update_ = new ::transit_realtime::TripUpdate(*from._impl_.trip_update_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.vehicle_ = new ::transit_realtime::VehiclePosition(*from._impl_.vehicle_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.alert_ = new ::transit_realtime::Alert(*from._impl_.alert_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.shape_ = new ::transit_realtime::Shape(*from._impl_.shape_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.stop_ = new ::transit_realtime::Stop(*from._impl_.stop_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.trip_modifications_ = new ::transit_realtime::TripModifications(*from._impl_.trip_modifications_);
  }
  _this->_impl_.is_deleted_ = from._impl_.is_deleted_;
  // @@protoc_insertion_point(copy_constructor:transit_realtime.FeedEntity)
}

inline void FeedEntity::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.trip_update_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.alert_){nullptr}
    , decltype(_impl_.shape_){nullptr}
    , decltype(_impl_.stop_){nullptr}
    , decltype(_impl_.trip_modifications_){nullptr}
    , decltype(_impl_.is_deleted_) { false }

  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FeedEntity::~FeedEntity() {
  // @@protoc_insertion_point(destructor:transit_realtime.FeedEntity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FeedEntity::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.trip_update_;
  if (this != internal_default_instance()) delete _impl_.vehicle_;
  if (this != internal_default_instance()) delete _impl_.alert_;
  if (this != internal_default_instance()) delete _impl_.shape_;
  if (this != internal_default_instance()) delete _impl_.stop_;
  if (this != internal_default_instance()) delete _impl_.trip_modifications_;
}

void FeedEntity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FeedEntity::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.FeedEntity)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.trip_update_ != nullptr);
      _impl_.trip_update_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.vehicle_ != nullptr);
      _impl_.vehicle_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.alert_ != nullptr);
      _impl_.alert_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.shape_ != nullptr);
      _impl_.shape_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.stop_ != nullptr);
      _impl_.stop_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.trip_modifications_ != nullptr);
      _impl_.trip_modifications_->Clear();
    }
  }
  _impl_.is_deleted_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FeedEntity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.FeedEntity.id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional bool is_deleted = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_is_deleted(&has_bits);
          _impl_.is_deleted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripUpdate trip_update = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_trip_update(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehiclePosition vehicle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_vehicle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Alert alert = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_alert(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Shape shape = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_shape(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Stop stop = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripModifications trip_modifications = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_trip_modifications(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* FeedEntity::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.FeedEntity)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.FeedEntity.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional bool is_deleted = 2 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        2, this->_internal_is_deleted(), target);
  }

  // optional .transit_realtime.TripUpdate trip_update = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::trip_update(this),
        _Internal::trip_update(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.VehiclePosition vehicle = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::vehicle(this),
        _Internal::vehicle(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.Alert alert = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::alert(this),
        _Internal::alert(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.Shape shape = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::shape(this),
        _Internal::shape(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.Stop stop = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::stop(this),
        _Internal::stop(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TripModifications trip_modifications = 8;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::trip_modifications(this),
        _Internal::trip_modifications(this).GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.FeedEntity)
  return target;
}

::size_t FeedEntity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.FeedEntity)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required string id = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_id());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .transit_realtime.TripUpdate trip_update = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trip_update_);
    }

    // optional .transit_realtime.VehiclePosition vehicle = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vehicle_);
    }

    // optional .transit_realtime.Alert alert = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.alert_);
    }

    // optional .transit_realtime.Shape shape = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.shape_);
    }

    // optional .transit_realtime.Stop stop = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stop_);
    }

    // optional .transit_realtime.TripModifications trip_modifications = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trip_modifications_);
    }

    // optional bool is_deleted = 2 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 2;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FeedEntity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FeedEntity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FeedEntity::GetClassData() const { return &_class_data_; }


void FeedEntity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FeedEntity*>(&to_msg);
  auto& from = static_cast<const FeedEntity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.FeedEntity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_trip_update()->::transit_realtime::TripUpdate::MergeFrom(
          from._internal_trip_update());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_vehicle()->::transit_realtime::VehiclePosition::MergeFrom(
          from._internal_vehicle());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_alert()->::transit_realtime::Alert::MergeFrom(
          from._internal_alert());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_shape()->::transit_realtime::Shape::MergeFrom(
          from._internal_shape());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_stop()->::transit_realtime::Stop::MergeFrom(
          from._internal_stop());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_trip_modifications()->::transit_realtime::TripModifications::MergeFrom(
          from._internal_trip_modifications());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.is_deleted_ = from._impl_.is_deleted_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FeedEntity::CopyFrom(const FeedEntity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.FeedEntity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FeedEntity::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.trip_update_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.vehicle_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.alert_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (!_impl_.shape_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (!_impl_.stop_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (!_impl_.trip_modifications_->IsInitialized()) return false;
  }
  return true;
}

void FeedEntity::InternalSwap(FeedEntity* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FeedEntity, _impl_.is_deleted_)
      + sizeof(FeedEntity::_impl_.is_deleted_)
      - PROTOBUF_FIELD_OFFSET(FeedEntity, _impl_.trip_update_)>(
          reinterpret_cast<char*>(&_impl_.trip_update_),
          reinterpret_cast<char*>(&other->_impl_.trip_update_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FeedEntity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[2]);
}
// ===================================================================

class TripUpdate_StopTimeEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<TripUpdate_StopTimeEvent>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripUpdate_StopTimeEvent, _impl_._has_bits_);
  static void set_has_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_uncertainty(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

TripUpdate_StopTimeEvent::TripUpdate_StopTimeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripUpdate.StopTimeEvent)
}
TripUpdate_StopTimeEvent::TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripUpdate_StopTimeEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_) {}

    , decltype(_impl_.delay_) {}

    , decltype(_impl_.uncertainty_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.uncertainty_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.uncertainty_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripUpdate.StopTimeEvent)
}

inline void TripUpdate_StopTimeEvent::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_) { ::int64_t{0} }

    , decltype(_impl_.delay_) { 0 }

    , decltype(_impl_.uncertainty_) { 0 }

  };
}

TripUpdate_StopTimeEvent::~TripUpdate_StopTimeEvent() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripUpdate.StopTimeEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripUpdate_StopTimeEvent::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
}

void TripUpdate_StopTimeEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripUpdate_StopTimeEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripUpdate.StopTimeEvent)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.uncertainty_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.uncertainty_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripUpdate_StopTimeEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 delay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_delay(&has_bits);
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int64 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 uncertainty = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_uncertainty(&has_bits);
          _impl_.uncertainty_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripUpdate_StopTimeEvent::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripUpdate.StopTimeEvent)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 delay = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_delay(), target);
  }

  // optional int64 time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_time(), target);
  }

  // optional int32 uncertainty = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_uncertainty(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripUpdate.StopTimeEvent)
  return target;
}

::size_t TripUpdate_StopTimeEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripUpdate.StopTimeEvent)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 time = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
          this->_internal_time());
    }

    // optional int32 delay = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_delay());
    }

    // optional int32 uncertainty = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_uncertainty());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripUpdate_StopTimeEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripUpdate_StopTimeEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripUpdate_StopTimeEvent::GetClassData() const { return &_class_data_; }


void TripUpdate_StopTimeEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripUpdate_StopTimeEvent*>(&to_msg);
  auto& from = static_cast<const TripUpdate_StopTimeEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripUpdate.StopTimeEvent)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.delay_ = from._impl_.delay_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.uncertainty_ = from._impl_.uncertainty_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripUpdate_StopTimeEvent::CopyFrom(const TripUpdate_StopTimeEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripUpdate.StopTimeEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripUpdate_StopTimeEvent::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void TripUpdate_StopTimeEvent::InternalSwap(TripUpdate_StopTimeEvent* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripUpdate_StopTimeEvent, _impl_.uncertainty_)
      + sizeof(TripUpdate_StopTimeEvent::_impl_.uncertainty_)
      - PROTOBUF_FIELD_OFFSET(TripUpdate_StopTimeEvent, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TripUpdate_StopTimeEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[3]);
}
// ===================================================================

class TripUpdate_StopTimeUpdate_StopTimeProperties::_Internal {
 public:
  using HasBits = decltype(std::declval<TripUpdate_StopTimeUpdate_StopTimeProperties>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripUpdate_StopTimeUpdate_StopTimeProperties, _impl_._has_bits_);
  static void set_has_assigned_stop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TripUpdate_StopTimeUpdate_StopTimeProperties::TripUpdate_StopTimeUpdate_StopTimeProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
}
TripUpdate_StopTimeUpdate_StopTimeProperties::TripUpdate_StopTimeUpdate_StopTimeProperties(const TripUpdate_StopTimeUpdate_StopTimeProperties& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripUpdate_StopTimeUpdate_StopTimeProperties* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assigned_stop_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.assigned_stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.assigned_stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.assigned_stop_id_.Set(from._internal_assigned_stop_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
}

inline void TripUpdate_StopTimeUpdate_StopTimeProperties::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.assigned_stop_id_) {}

  };
  _impl_.assigned_stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.assigned_stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripUpdate_StopTimeUpdate_StopTimeProperties::~TripUpdate_StopTimeUpdate_StopTimeProperties() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripUpdate_StopTimeUpdate_StopTimeProperties::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.assigned_stop_id_.Destroy();
}

void TripUpdate_StopTimeUpdate_StopTimeProperties::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripUpdate_StopTimeUpdate_StopTimeProperties::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.assigned_stop_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripUpdate_StopTimeUpdate_StopTimeProperties::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string assigned_stop_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_assigned_stop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripUpdate_StopTimeUpdate_StopTimeProperties::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string assigned_stop_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_assigned_stop_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties.assigned_stop_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
  return target;
}

::size_t TripUpdate_StopTimeUpdate_StopTimeProperties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string assigned_stop_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_assigned_stop_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripUpdate_StopTimeUpdate_StopTimeProperties::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripUpdate_StopTimeUpdate_StopTimeProperties::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripUpdate_StopTimeUpdate_StopTimeProperties::GetClassData() const { return &_class_data_; }


void TripUpdate_StopTimeUpdate_StopTimeProperties::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripUpdate_StopTimeUpdate_StopTimeProperties*>(&to_msg);
  auto& from = static_cast<const TripUpdate_StopTimeUpdate_StopTimeProperties&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_assigned_stop_id(from._internal_assigned_stop_id());
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripUpdate_StopTimeUpdate_StopTimeProperties::CopyFrom(const TripUpdate_StopTimeUpdate_StopTimeProperties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripUpdate_StopTimeUpdate_StopTimeProperties::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void TripUpdate_StopTimeUpdate_StopTimeProperties::InternalSwap(TripUpdate_StopTimeUpdate_StopTimeProperties* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.assigned_stop_id_, lhs_arena,
                                       &other->_impl_.assigned_stop_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TripUpdate_StopTimeUpdate_StopTimeProperties::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[4]);
}
// ===================================================================

class TripUpdate_StopTimeUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<TripUpdate_StopTimeUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripUpdate_StopTimeUpdate, _impl_._has_bits_);
  static void set_has_stop_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_stop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::transit_realtime::TripUpdate_StopTimeEvent& arrival(const TripUpdate_StopTimeUpdate* msg);
  static void set_has_arrival(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::transit_realtime::TripUpdate_StopTimeEvent& departure(const TripUpdate_StopTimeUpdate* msg);
  static void set_has_departure(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_departure_occupancy_status(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_schedule_relationship(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties& stop_time_properties(const TripUpdate_StopTimeUpdate* msg);
  static void set_has_stop_time_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::transit_realtime::TripUpdate_StopTimeEvent&
TripUpdate_StopTimeUpdate::_Internal::arrival(const TripUpdate_StopTimeUpdate* msg) {
  return *msg->_impl_.arrival_;
}
const ::transit_realtime::TripUpdate_StopTimeEvent&
TripUpdate_StopTimeUpdate::_Internal::departure(const TripUpdate_StopTimeUpdate* msg) {
  return *msg->_impl_.departure_;
}
const ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties&
TripUpdate_StopTimeUpdate::_Internal::stop_time_properties(const TripUpdate_StopTimeUpdate* msg) {
  return *msg->_impl_.stop_time_properties_;
}
TripUpdate_StopTimeUpdate::TripUpdate_StopTimeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripUpdate.StopTimeUpdate)
}
TripUpdate_StopTimeUpdate::TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripUpdate_StopTimeUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.arrival_){nullptr}
    , decltype(_impl_.departure_){nullptr}
    , decltype(_impl_.stop_time_properties_){nullptr}
    , decltype(_impl_.stop_sequence_) {}

    , decltype(_impl_.schedule_relationship_) {}

    , decltype(_impl_.departure_occupancy_status_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.stop_id_.Set(from._internal_stop_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.arrival_ = new ::transit_realtime::TripUpdate_StopTimeEvent(*from._impl_.arrival_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.departure_ = new ::transit_realtime::TripUpdate_StopTimeEvent(*from._impl_.departure_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.stop_time_properties_ = new ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties(*from._impl_.stop_time_properties_);
  }
  ::memcpy(&_impl_.stop_sequence_, &from._impl_.stop_sequence_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.departure_occupancy_status_) -
    reinterpret_cast<char*>(&_impl_.stop_sequence_)) + sizeof(_impl_.departure_occupancy_status_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripUpdate.StopTimeUpdate)
}

inline void TripUpdate_StopTimeUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.arrival_){nullptr}
    , decltype(_impl_.departure_){nullptr}
    , decltype(_impl_.stop_time_properties_){nullptr}
    , decltype(_impl_.stop_sequence_) { 0u }

    , decltype(_impl_.schedule_relationship_) { 0 }

    , decltype(_impl_.departure_occupancy_status_) { 0 }

  };
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripUpdate_StopTimeUpdate::~TripUpdate_StopTimeUpdate() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripUpdate.StopTimeUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripUpdate_StopTimeUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.stop_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.arrival_;
  if (this != internal_default_instance()) delete _impl_.departure_;
  if (this != internal_default_instance()) delete _impl_.stop_time_properties_;
}

void TripUpdate_StopTimeUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripUpdate_StopTimeUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripUpdate.StopTimeUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stop_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.arrival_ != nullptr);
      _impl_.arrival_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.departure_ != nullptr);
      _impl_.departure_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.stop_time_properties_ != nullptr);
      _impl_.stop_time_properties_->Clear();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&_impl_.stop_sequence_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.departure_occupancy_status_) -
        reinterpret_cast<char*>(&_impl_.stop_sequence_)) + sizeof(_impl_.departure_occupancy_status_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripUpdate_StopTimeUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 stop_sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_stop_sequence(&has_bits);
          _impl_.stop_sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_arrival(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_departure(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string stop_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_stop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripUpdate.StopTimeUpdate.stop_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(static_cast<int>(val)))) {
            _internal_set_schedule_relationship(static_cast<::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_time_properties(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_departure_occupancy_status(static_cast<::transit_realtime::VehiclePosition_OccupancyStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripUpdate_StopTimeUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripUpdate.StopTimeUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 stop_sequence = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_stop_sequence(), target);
  }

  // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::arrival(this),
        _Internal::arrival(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::departure(this),
        _Internal::departure(this).GetCachedSize(), target, stream);
  }

  // optional string stop_id = 4;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_stop_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripUpdate.StopTimeUpdate.stop_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_schedule_relationship(), target);
  }

  // optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::stop_time_properties(this),
        _Internal::stop_time_properties(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_departure_occupancy_status(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripUpdate.StopTimeUpdate)
  return target;
}

::size_t TripUpdate_StopTimeUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripUpdate.StopTimeUpdate)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string stop_id = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_stop_id());
    }

    // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.arrival_);
    }

    // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.departure_);
    }

    // optional .transit_realtime.TripUpdate.StopTimeUpdate.StopTimeProperties stop_time_properties = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stop_time_properties_);
    }

    // optional uint32 stop_sequence = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_stop_sequence());
    }

    // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_schedule_relationship());
    }

    // optional .transit_realtime.VehiclePosition.OccupancyStatus departure_occupancy_status = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_departure_occupancy_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripUpdate_StopTimeUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripUpdate_StopTimeUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripUpdate_StopTimeUpdate::GetClassData() const { return &_class_data_; }


void TripUpdate_StopTimeUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripUpdate_StopTimeUpdate*>(&to_msg);
  auto& from = static_cast<const TripUpdate_StopTimeUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripUpdate.StopTimeUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stop_id(from._internal_stop_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_arrival()->::transit_realtime::TripUpdate_StopTimeEvent::MergeFrom(
          from._internal_arrival());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_departure()->::transit_realtime::TripUpdate_StopTimeEvent::MergeFrom(
          from._internal_departure());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_stop_time_properties()->::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties::MergeFrom(
          from._internal_stop_time_properties());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.stop_sequence_ = from._impl_.stop_sequence_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.schedule_relationship_ = from._impl_.schedule_relationship_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.departure_occupancy_status_ = from._impl_.departure_occupancy_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripUpdate_StopTimeUpdate::CopyFrom(const TripUpdate_StopTimeUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripUpdate.StopTimeUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripUpdate_StopTimeUpdate::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.arrival_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.departure_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.stop_time_properties_->IsInitialized()) return false;
  }
  return true;
}

void TripUpdate_StopTimeUpdate::InternalSwap(TripUpdate_StopTimeUpdate* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_id_, lhs_arena,
                                       &other->_impl_.stop_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripUpdate_StopTimeUpdate, _impl_.departure_occupancy_status_)
      + sizeof(TripUpdate_StopTimeUpdate::_impl_.departure_occupancy_status_)
      - PROTOBUF_FIELD_OFFSET(TripUpdate_StopTimeUpdate, _impl_.arrival_)>(
          reinterpret_cast<char*>(&_impl_.arrival_),
          reinterpret_cast<char*>(&other->_impl_.arrival_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TripUpdate_StopTimeUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[5]);
}
// ===================================================================

class TripUpdate_TripProperties::_Internal {
 public:
  using HasBits = decltype(std::declval<TripUpdate_TripProperties>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripUpdate_TripProperties, _impl_._has_bits_);
  static void set_has_trip_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_shape_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TripUpdate_TripProperties::TripUpdate_TripProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripUpdate.TripProperties)
}
TripUpdate_TripProperties::TripUpdate_TripProperties(const TripUpdate_TripProperties& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripUpdate_TripProperties* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trip_id_) {}

    , decltype(_impl_.start_date_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.shape_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.trip_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trip_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.trip_id_.Set(from._internal_trip_id(), _this->GetArenaForAllocation());
  }
  _impl_.start_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_date_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.start_date_.Set(from._internal_start_date(), _this->GetArenaForAllocation());
  }
  _impl_.start_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_time_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.start_time_.Set(from._internal_start_time(), _this->GetArenaForAllocation());
  }
  _impl_.shape_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.shape_id_.Set(from._internal_shape_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripUpdate.TripProperties)
}

inline void TripUpdate_TripProperties::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trip_id_) {}

    , decltype(_impl_.start_date_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.shape_id_) {}

  };
  _impl_.trip_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trip_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_date_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_time_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.shape_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripUpdate_TripProperties::~TripUpdate_TripProperties() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripUpdate.TripProperties)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripUpdate_TripProperties::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.trip_id_.Destroy();
  _impl_.start_date_.Destroy();
  _impl_.start_time_.Destroy();
  _impl_.shape_id_.Destroy();
}

void TripUpdate_TripProperties::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripUpdate_TripProperties::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripUpdate.TripProperties)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.trip_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.start_date_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.start_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.shape_id_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripUpdate_TripProperties::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string trip_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_trip_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripUpdate.TripProperties.trip_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string start_date = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_start_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripUpdate.TripProperties.start_date");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string start_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_start_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripUpdate.TripProperties.start_time");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string shape_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_shape_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripUpdate.TripProperties.shape_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripUpdate_TripProperties::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripUpdate.TripProperties)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string trip_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_trip_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripUpdate.TripProperties.trip_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string start_date = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_start_date();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripUpdate.TripProperties.start_date");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string start_time = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_start_time();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripUpdate.TripProperties.start_time");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string shape_id = 4;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_shape_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripUpdate.TripProperties.shape_id");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripUpdate.TripProperties)
  return target;
}

::size_t TripUpdate_TripProperties::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripUpdate.TripProperties)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string trip_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_trip_id());
    }

    // optional string start_date = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_start_date());
    }

    // optional string start_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_start_time());
    }

    // optional string shape_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_shape_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripUpdate_TripProperties::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripUpdate_TripProperties::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripUpdate_TripProperties::GetClassData() const { return &_class_data_; }


void TripUpdate_TripProperties::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripUpdate_TripProperties*>(&to_msg);
  auto& from = static_cast<const TripUpdate_TripProperties&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripUpdate.TripProperties)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_trip_id(from._internal_trip_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_start_date(from._internal_start_date());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_start_time(from._internal_start_time());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_shape_id(from._internal_shape_id());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripUpdate_TripProperties::CopyFrom(const TripUpdate_TripProperties& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripUpdate.TripProperties)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripUpdate_TripProperties::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void TripUpdate_TripProperties::InternalSwap(TripUpdate_TripProperties* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trip_id_, lhs_arena,
                                       &other->_impl_.trip_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_date_, lhs_arena,
                                       &other->_impl_.start_date_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_time_, lhs_arena,
                                       &other->_impl_.start_time_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.shape_id_, lhs_arena,
                                       &other->_impl_.shape_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TripUpdate_TripProperties::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[6]);
}
// ===================================================================

class TripUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<TripUpdate>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripUpdate, _impl_._has_bits_);
  static const ::transit_realtime::TripDescriptor& trip(const TripUpdate* msg);
  static void set_has_trip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::transit_realtime::VehicleDescriptor& vehicle(const TripUpdate* msg);
  static void set_has_vehicle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::transit_realtime::TripUpdate_TripProperties& trip_properties(const TripUpdate* msg);
  static void set_has_trip_properties(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::transit_realtime::TripDescriptor&
TripUpdate::_Internal::trip(const TripUpdate* msg) {
  return *msg->_impl_.trip_;
}
const ::transit_realtime::VehicleDescriptor&
TripUpdate::_Internal::vehicle(const TripUpdate* msg) {
  return *msg->_impl_.vehicle_;
}
const ::transit_realtime::TripUpdate_TripProperties&
TripUpdate::_Internal::trip_properties(const TripUpdate* msg) {
  return *msg->_impl_.trip_properties_;
}
TripUpdate::TripUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripUpdate)
}
TripUpdate::TripUpdate(const TripUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripUpdate* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_time_update_){from._impl_.stop_time_update_}
    , decltype(_impl_.trip_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.trip_properties_){nullptr}
    , decltype(_impl_.timestamp_) {}

    , decltype(_impl_.delay_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.trip_ = new ::transit_realtime::TripDescriptor(*from._impl_.trip_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.vehicle_ = new ::transit_realtime::VehicleDescriptor(*from._impl_.vehicle_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.trip_properties_ = new ::transit_realtime::TripUpdate_TripProperties(*from._impl_.trip_properties_);
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.delay_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.delay_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripUpdate)
}

inline void TripUpdate::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_time_update_){arena}
    , decltype(_impl_.trip_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.trip_properties_){nullptr}
    , decltype(_impl_.timestamp_) { ::uint64_t{0u} }

    , decltype(_impl_.delay_) { 0 }

  };
}

TripUpdate::~TripUpdate() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripUpdate::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_stop_time_update()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.trip_;
  if (this != internal_default_instance()) delete _impl_.vehicle_;
  if (this != internal_default_instance()) delete _impl_.trip_properties_;
}

void TripUpdate::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripUpdate)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_stop_time_update()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.trip_ != nullptr);
      _impl_.trip_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.vehicle_ != nullptr);
      _impl_.vehicle_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.trip_properties_ != nullptr);
      _impl_.trip_properties_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.timestamp_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.delay_) -
        reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.delay_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .transit_realtime.TripDescriptor trip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_trip(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stop_time_update(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehicleDescriptor vehicle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_vehicle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 delay = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_delay(&has_bits);
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_trip_properties(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripUpdate::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripUpdate)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .transit_realtime.TripDescriptor trip = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::trip(this),
        _Internal::trip(this).GetCachedSize(), target, stream);
  }

  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stop_time_update_size()); i < n; i++) {
    const auto& repfield = this->_internal_stop_time_update(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.VehicleDescriptor vehicle = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::vehicle(this),
        _Internal::vehicle(this).GetCachedSize(), target, stream);
  }

  // optional uint64 timestamp = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this->_internal_timestamp(), target);
  }

  // optional int32 delay = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        5, this->_internal_delay(), target);
  }

  // optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::trip_properties(this),
        _Internal::trip_properties(this).GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripUpdate)
  return target;
}

::size_t TripUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripUpdate)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required .transit_realtime.TripDescriptor trip = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.trip_);
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  total_size += 1UL * this->_internal_stop_time_update_size();
  for (const auto& msg : this->_internal_stop_time_update()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional .transit_realtime.VehicleDescriptor vehicle = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vehicle_);
    }

    // optional .transit_realtime.TripUpdate.TripProperties trip_properties = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trip_properties_);
    }

    // optional uint64 timestamp = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_timestamp());
    }

    // optional int32 delay = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_delay());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripUpdate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripUpdate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripUpdate::GetClassData() const { return &_class_data_; }


void TripUpdate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripUpdate*>(&to_msg);
  auto& from = static_cast<const TripUpdate&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripUpdate)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_stop_time_update()->MergeFrom(from._internal_stop_time_update());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_trip()->::transit_realtime::TripDescriptor::MergeFrom(
          from._internal_trip());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_vehicle()->::transit_realtime::VehicleDescriptor::MergeFrom(
          from._internal_vehicle());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_trip_properties()->::transit_realtime::TripUpdate_TripProperties::MergeFrom(
          from._internal_trip_properties());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.delay_ = from._impl_.delay_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripUpdate::CopyFrom(const TripUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripUpdate::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_stop_time_update()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.trip_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.vehicle_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.trip_properties_->IsInitialized()) return false;
  }
  return true;
}

void TripUpdate::InternalSwap(TripUpdate* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_stop_time_update()->InternalSwap(other->_internal_mutable_stop_time_update());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripUpdate, _impl_.delay_)
      + sizeof(TripUpdate::_impl_.delay_)
      - PROTOBUF_FIELD_OFFSET(TripUpdate, _impl_.trip_)>(
          reinterpret_cast<char*>(&_impl_.trip_),
          reinterpret_cast<char*>(&other->_impl_.trip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TripUpdate::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[7]);
}
// ===================================================================

class VehiclePosition_CarriageDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<VehiclePosition_CarriageDetails>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VehiclePosition_CarriageDetails, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_occupancy_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_occupancy_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_carriage_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

VehiclePosition_CarriageDetails::VehiclePosition_CarriageDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.VehiclePosition.CarriageDetails)
}
VehiclePosition_CarriageDetails::VehiclePosition_CarriageDetails(const VehiclePosition_CarriageDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VehiclePosition_CarriageDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.label_) {}

    , decltype(_impl_.carriage_sequence_) {}

    , decltype(_impl_.occupancy_status_) {}

    , decltype(_impl_.occupancy_percentage_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.label_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.label_.Set(from._internal_label(), _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.carriage_sequence_, &from._impl_.carriage_sequence_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.occupancy_percentage_) -
    reinterpret_cast<char*>(&_impl_.carriage_sequence_)) + sizeof(_impl_.occupancy_percentage_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.VehiclePosition.CarriageDetails)
}

inline void VehiclePosition_CarriageDetails::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.label_) {}

    , decltype(_impl_.carriage_sequence_) { 0u }

    , decltype(_impl_.occupancy_status_) { 7 }

    , decltype(_impl_.occupancy_percentage_) { -1 }

  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.label_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VehiclePosition_CarriageDetails::~VehiclePosition_CarriageDetails() {
  // @@protoc_insertion_point(destructor:transit_realtime.VehiclePosition.CarriageDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VehiclePosition_CarriageDetails::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.id_.Destroy();
  _impl_.label_.Destroy();
}

void VehiclePosition_CarriageDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VehiclePosition_CarriageDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.VehiclePosition.CarriageDetails)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    _impl_.carriage_sequence_ = 0u;
    _impl_.occupancy_status_ = 7;
    _impl_.occupancy_percentage_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VehiclePosition_CarriageDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.VehiclePosition.CarriageDetails.id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.VehiclePosition.CarriageDetails.label");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_occupancy_status(static_cast<::transit_realtime::VehiclePosition_OccupancyStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 occupancy_percentage = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_occupancy_percentage(&has_bits);
          _impl_.occupancy_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 carriage_sequence = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_carriage_sequence(&has_bits);
          _impl_.carriage_sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VehiclePosition_CarriageDetails::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.VehiclePosition.CarriageDetails)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.VehiclePosition.CarriageDetails.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string label = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_label();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.VehiclePosition.CarriageDetails.label");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_occupancy_status(), target);
  }

  // optional int32 occupancy_percentage = 4 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        4, this->_internal_occupancy_percentage(), target);
  }

  // optional uint32 carriage_sequence = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        5, this->_internal_carriage_sequence(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.VehiclePosition.CarriageDetails)
  return target;
}

::size_t VehiclePosition_CarriageDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.VehiclePosition.CarriageDetails)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // optional string label = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_label());
    }

    // optional uint32 carriage_sequence = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_carriage_sequence());
    }

    // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 3 [default = NO_DATA_AVAILABLE];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_occupancy_status());
    }

    // optional int32 occupancy_percentage = 4 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_occupancy_percentage());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VehiclePosition_CarriageDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VehiclePosition_CarriageDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VehiclePosition_CarriageDetails::GetClassData() const { return &_class_data_; }


void VehiclePosition_CarriageDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VehiclePosition_CarriageDetails*>(&to_msg);
  auto& from = static_cast<const VehiclePosition_CarriageDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.VehiclePosition.CarriageDetails)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.carriage_sequence_ = from._impl_.carriage_sequence_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.occupancy_status_ = from._impl_.occupancy_status_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.occupancy_percentage_ = from._impl_.occupancy_percentage_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VehiclePosition_CarriageDetails::CopyFrom(const VehiclePosition_CarriageDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.VehiclePosition.CarriageDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehiclePosition_CarriageDetails::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void VehiclePosition_CarriageDetails::InternalSwap(VehiclePosition_CarriageDetails* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.label_, lhs_arena,
                                       &other->_impl_.label_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VehiclePosition_CarriageDetails, _impl_.occupancy_percentage_)
      + sizeof(VehiclePosition_CarriageDetails::_impl_.occupancy_percentage_)
      - PROTOBUF_FIELD_OFFSET(VehiclePosition_CarriageDetails, _impl_.carriage_sequence_)>(
          reinterpret_cast<char*>(&_impl_.carriage_sequence_),
          reinterpret_cast<char*>(&other->_impl_.carriage_sequence_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VehiclePosition_CarriageDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[8]);
}
// ===================================================================

class VehiclePosition::_Internal {
 public:
  using HasBits = decltype(std::declval<VehiclePosition>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VehiclePosition, _impl_._has_bits_);
  static const ::transit_realtime::TripDescriptor& trip(const VehiclePosition* msg);
  static void set_has_trip(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::transit_realtime::VehicleDescriptor& vehicle(const VehiclePosition* msg);
  static void set_has_vehicle(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::transit_realtime::Position& position(const VehiclePosition* msg);
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_current_stop_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_stop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current_status(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_congestion_level(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_occupancy_status(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_occupancy_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::transit_realtime::TripDescriptor&
VehiclePosition::_Internal::trip(const VehiclePosition* msg) {
  return *msg->_impl_.trip_;
}
const ::transit_realtime::VehicleDescriptor&
VehiclePosition::_Internal::vehicle(const VehiclePosition* msg) {
  return *msg->_impl_.vehicle_;
}
const ::transit_realtime::Position&
VehiclePosition::_Internal::position(const VehiclePosition* msg) {
  return *msg->_impl_.position_;
}
VehiclePosition::VehiclePosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.VehiclePosition)
}
VehiclePosition::VehiclePosition(const VehiclePosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VehiclePosition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.multi_carriage_details_){from._impl_.multi_carriage_details_}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.trip_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.current_stop_sequence_) {}

    , decltype(_impl_.congestion_level_) {}

    , decltype(_impl_.timestamp_) {}

    , decltype(_impl_.occupancy_status_) {}

    , decltype(_impl_.occupancy_percentage_) {}

    , decltype(_impl_.current_status_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.stop_id_.Set(from._internal_stop_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.trip_ = new ::transit_realtime::TripDescriptor(*from._impl_.trip_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.position_ = new ::transit_realtime::Position(*from._impl_.position_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.vehicle_ = new ::transit_realtime::VehicleDescriptor(*from._impl_.vehicle_);
  }
  ::memcpy(&_impl_.current_stop_sequence_, &from._impl_.current_stop_sequence_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.current_status_) -
    reinterpret_cast<char*>(&_impl_.current_stop_sequence_)) + sizeof(_impl_.current_status_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.VehiclePosition)
}

inline void VehiclePosition::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.multi_carriage_details_){arena}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.trip_){nullptr}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.vehicle_){nullptr}
    , decltype(_impl_.current_stop_sequence_) { 0u }

    , decltype(_impl_.congestion_level_) { 0 }

    , decltype(_impl_.timestamp_) { ::uint64_t{0u} }

    , decltype(_impl_.occupancy_status_) { 0 }

    , decltype(_impl_.occupancy_percentage_) { 0u }

    , decltype(_impl_.current_status_) { 2 }

  };
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VehiclePosition::~VehiclePosition() {
  // @@protoc_insertion_point(destructor:transit_realtime.VehiclePosition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VehiclePosition::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_multi_carriage_details()->~RepeatedPtrField();
  _impl_.stop_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.trip_;
  if (this != internal_default_instance()) delete _impl_.position_;
  if (this != internal_default_instance()) delete _impl_.vehicle_;
}

void VehiclePosition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VehiclePosition::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.VehiclePosition)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_multi_carriage_details()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stop_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.trip_ != nullptr);
      _impl_.trip_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.position_ != nullptr);
      _impl_.position_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.vehicle_ != nullptr);
      _impl_.vehicle_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.current_stop_sequence_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.occupancy_status_) -
        reinterpret_cast<char*>(&_impl_.current_stop_sequence_)) + sizeof(_impl_.occupancy_status_));
  }
  if (cached_has_bits & 0x00000300u) {
    _impl_.occupancy_percentage_ = 0u;
    _impl_.current_status_ = 2;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VehiclePosition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .transit_realtime.TripDescriptor trip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_trip(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Position position = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 current_stop_sequence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_current_stop_sequence(&has_bits);
          _impl_.current_stop_sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::VehiclePosition_VehicleStopStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_current_status(static_cast<::transit_realtime::VehiclePosition_VehicleStopStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 timestamp = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::VehiclePosition_CongestionLevel_IsValid(static_cast<int>(val)))) {
            _internal_set_congestion_level(static_cast<::transit_realtime::VehiclePosition_CongestionLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string stop_id = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_stop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.VehiclePosition.stop_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehicleDescriptor vehicle = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_vehicle(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 72)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::VehiclePosition_OccupancyStatus_IsValid(static_cast<int>(val)))) {
            _internal_set_occupancy_status(static_cast<::transit_realtime::VehiclePosition_OccupancyStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 occupancy_percentage = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 80)) {
          _Internal::set_has_occupancy_percentage(&has_bits);
          _impl_.occupancy_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_multi_carriage_details(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VehiclePosition::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.VehiclePosition)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .transit_realtime.TripDescriptor trip = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::trip(this),
        _Internal::trip(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.Position position = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // optional uint32 current_stop_sequence = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_current_stop_sequence(), target);
  }

  // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_current_status(), target);
  }

  // optional uint64 timestamp = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_timestamp(), target);
  }

  // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_congestion_level(), target);
  }

  // optional string stop_id = 7;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_stop_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.VehiclePosition.stop_id");
    target = stream->WriteStringMaybeAliased(7, _s, target);
  }

  // optional .transit_realtime.VehicleDescriptor vehicle = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::vehicle(this),
        _Internal::vehicle(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        9, this->_internal_occupancy_status(), target);
  }

  // optional uint32 occupancy_percentage = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        10, this->_internal_occupancy_percentage(), target);
  }

  // repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_multi_carriage_details_size()); i < n; i++) {
    const auto& repfield = this->_internal_multi_carriage_details(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.VehiclePosition)
  return target;
}

::size_t VehiclePosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.VehiclePosition)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.VehiclePosition.CarriageDetails multi_carriage_details = 11;
  total_size += 1UL * this->_internal_multi_carriage_details_size();
  for (const auto& msg : this->_internal_multi_carriage_details()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string stop_id = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_stop_id());
    }

    // optional .transit_realtime.TripDescriptor trip = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trip_);
    }

    // optional .transit_realtime.Position position = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.position_);
    }

    // optional .transit_realtime.VehicleDescriptor vehicle = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.vehicle_);
    }

    // optional uint32 current_stop_sequence = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_current_stop_sequence());
    }

    // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_congestion_level());
    }

    // optional uint64 timestamp = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_timestamp());
    }

    // optional .transit_realtime.VehiclePosition.OccupancyStatus occupancy_status = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_occupancy_status());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 occupancy_percentage = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_occupancy_percentage());
    }

    // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_current_status());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VehiclePosition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VehiclePosition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VehiclePosition::GetClassData() const { return &_class_data_; }


void VehiclePosition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VehiclePosition*>(&to_msg);
  auto& from = static_cast<const VehiclePosition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.VehiclePosition)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_multi_carriage_details()->MergeFrom(from._internal_multi_carriage_details());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stop_id(from._internal_stop_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_trip()->::transit_realtime::TripDescriptor::MergeFrom(
          from._internal_trip());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_position()->::transit_realtime::Position::MergeFrom(
          from._internal_position());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_vehicle()->::transit_realtime::VehicleDescriptor::MergeFrom(
          from._internal_vehicle());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.current_stop_sequence_ = from._impl_.current_stop_sequence_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.congestion_level_ = from._impl_.congestion_level_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.occupancy_status_ = from._impl_.occupancy_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.occupancy_percentage_ = from._impl_.occupancy_percentage_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.current_status_ = from._impl_.current_status_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VehiclePosition::CopyFrom(const VehiclePosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.VehiclePosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehiclePosition::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_multi_carriage_details()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.trip_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.position_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.vehicle_->IsInitialized()) return false;
  }
  return true;
}

void VehiclePosition::InternalSwap(VehiclePosition* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_multi_carriage_details()->InternalSwap(other->_internal_mutable_multi_carriage_details());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_id_, lhs_arena,
                                       &other->_impl_.stop_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VehiclePosition, _impl_.current_status_)
      + sizeof(VehiclePosition::_impl_.current_status_)
      - PROTOBUF_FIELD_OFFSET(VehiclePosition, _impl_.trip_)>(
          reinterpret_cast<char*>(&_impl_.trip_),
          reinterpret_cast<char*>(&other->_impl_.trip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VehiclePosition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[9]);
}
// ===================================================================

class Alert::_Internal {
 public:
  using HasBits = decltype(std::declval<Alert>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Alert, _impl_._has_bits_);
  static void set_has_cause(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_effect(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::transit_realtime::TranslatedString& url(const Alert* msg);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::transit_realtime::TranslatedString& header_text(const Alert* msg);
  static void set_has_header_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::transit_realtime::TranslatedString& description_text(const Alert* msg);
  static void set_has_description_text(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::transit_realtime::TranslatedString& tts_header_text(const Alert* msg);
  static void set_has_tts_header_text(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::transit_realtime::TranslatedString& tts_description_text(const Alert* msg);
  static void set_has_tts_description_text(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_severity_level(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::transit_realtime::TranslatedImage& image(const Alert* msg);
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::transit_realtime::TranslatedString& image_alternative_text(const Alert* msg);
  static void set_has_image_alternative_text(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::transit_realtime::TranslatedString& cause_detail(const Alert* msg);
  static void set_has_cause_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::transit_realtime::TranslatedString& effect_detail(const Alert* msg);
  static void set_has_effect_detail(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

const ::transit_realtime::TranslatedString&
Alert::_Internal::url(const Alert* msg) {
  return *msg->_impl_.url_;
}
const ::transit_realtime::TranslatedString&
Alert::_Internal::header_text(const Alert* msg) {
  return *msg->_impl_.header_text_;
}
const ::transit_realtime::TranslatedString&
Alert::_Internal::description_text(const Alert* msg) {
  return *msg->_impl_.description_text_;
}
const ::transit_realtime::TranslatedString&
Alert::_Internal::tts_header_text(const Alert* msg) {
  return *msg->_impl_.tts_header_text_;
}
const ::transit_realtime::TranslatedString&
Alert::_Internal::tts_description_text(const Alert* msg) {
  return *msg->_impl_.tts_description_text_;
}
const ::transit_realtime::TranslatedImage&
Alert::_Internal::image(const Alert* msg) {
  return *msg->_impl_.image_;
}
const ::transit_realtime::TranslatedString&
Alert::_Internal::image_alternative_text(const Alert* msg) {
  return *msg->_impl_.image_alternative_text_;
}
const ::transit_realtime::TranslatedString&
Alert::_Internal::cause_detail(const Alert* msg) {
  return *msg->_impl_.cause_detail_;
}
const ::transit_realtime::TranslatedString&
Alert::_Internal::effect_detail(const Alert* msg) {
  return *msg->_impl_.effect_detail_;
}
Alert::Alert(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.Alert)
}
Alert::Alert(const Alert& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Alert* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_period_){from._impl_.active_period_}
    , decltype(_impl_.informed_entity_){from._impl_.informed_entity_}
    , decltype(_impl_.url_){nullptr}
    , decltype(_impl_.header_text_){nullptr}
    , decltype(_impl_.description_text_){nullptr}
    , decltype(_impl_.tts_header_text_){nullptr}
    , decltype(_impl_.tts_description_text_){nullptr}
    , decltype(_impl_.image_){nullptr}
    , decltype(_impl_.image_alternative_text_){nullptr}
    , decltype(_impl_.cause_detail_){nullptr}
    , decltype(_impl_.effect_detail_){nullptr}
    , decltype(_impl_.severity_level_) {}

    , decltype(_impl_.cause_) {}

    , decltype(_impl_.effect_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.url_ = new ::transit_realtime::TranslatedString(*from._impl_.url_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.header_text_ = new ::transit_realtime::TranslatedString(*from._impl_.header_text_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.description_text_ = new ::transit_realtime::TranslatedString(*from._impl_.description_text_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.tts_header_text_ = new ::transit_realtime::TranslatedString(*from._impl_.tts_header_text_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.tts_description_text_ = new ::transit_realtime::TranslatedString(*from._impl_.tts_description_text_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.image_ = new ::transit_realtime::TranslatedImage(*from._impl_.image_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.image_alternative_text_ = new ::transit_realtime::TranslatedString(*from._impl_.image_alternative_text_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000080u) != 0) {
    _this->_impl_.cause_detail_ = new ::transit_realtime::TranslatedString(*from._impl_.cause_detail_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000100u) != 0) {
    _this->_impl_.effect_detail_ = new ::transit_realtime::TranslatedString(*from._impl_.effect_detail_);
  }
  ::memcpy(&_impl_.severity_level_, &from._impl_.severity_level_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.effect_) -
    reinterpret_cast<char*>(&_impl_.severity_level_)) + sizeof(_impl_.effect_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.Alert)
}

inline void Alert::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.active_period_){arena}
    , decltype(_impl_.informed_entity_){arena}
    , decltype(_impl_.url_){nullptr}
    , decltype(_impl_.header_text_){nullptr}
    , decltype(_impl_.description_text_){nullptr}
    , decltype(_impl_.tts_header_text_){nullptr}
    , decltype(_impl_.tts_description_text_){nullptr}
    , decltype(_impl_.image_){nullptr}
    , decltype(_impl_.image_alternative_text_){nullptr}
    , decltype(_impl_.cause_detail_){nullptr}
    , decltype(_impl_.effect_detail_){nullptr}
    , decltype(_impl_.severity_level_) { 1 }

    , decltype(_impl_.cause_) { 1 }

    , decltype(_impl_.effect_) { 8 }

  };
}

Alert::~Alert() {
  // @@protoc_insertion_point(destructor:transit_realtime.Alert)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Alert::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_active_period()->~RepeatedPtrField();
  _internal_mutable_informed_entity()->~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.url_;
  if (this != internal_default_instance()) delete _impl_.header_text_;
  if (this != internal_default_instance()) delete _impl_.description_text_;
  if (this != internal_default_instance()) delete _impl_.tts_header_text_;
  if (this != internal_default_instance()) delete _impl_.tts_description_text_;
  if (this != internal_default_instance()) delete _impl_.image_;
  if (this != internal_default_instance()) delete _impl_.image_alternative_text_;
  if (this != internal_default_instance()) delete _impl_.cause_detail_;
  if (this != internal_default_instance()) delete _impl_.effect_detail_;
}

void Alert::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Alert::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.Alert)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_active_period()->Clear();
  _internal_mutable_informed_entity()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.url_ != nullptr);
      _impl_.url_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.header_text_ != nullptr);
      _impl_.header_text_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.description_text_ != nullptr);
      _impl_.description_text_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.tts_header_text_ != nullptr);
      _impl_.tts_header_text_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.tts_description_text_ != nullptr);
      _impl_.tts_description_text_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.image_ != nullptr);
      _impl_.image_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.image_alternative_text_ != nullptr);
      _impl_.image_alternative_text_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.cause_detail_ != nullptr);
      _impl_.cause_detail_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      ABSL_DCHECK(_impl_.effect_detail_ != nullptr);
      _impl_.effect_detail_->Clear();
    }
    _impl_.severity_level_ = 1;
    _impl_.cause_ = 1;
    _impl_.effect_ = 8;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Alert::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .transit_realtime.TimeRange active_period = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_active_period(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .transit_realtime.EntitySelector informed_entity = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_informed_entity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::Alert_Cause_IsValid(static_cast<int>(val)))) {
            _internal_set_cause(static_cast<::transit_realtime::Alert_Cause>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::Alert_Effect_IsValid(static_cast<int>(val)))) {
            _internal_set_effect(static_cast<::transit_realtime::Alert_Effect>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString url = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_url(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString header_text = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_header_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString description_text = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_description_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString tts_header_text = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_tts_header_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString tts_description_text = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_tts_description_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 112)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::Alert_SeverityLevel_IsValid(static_cast<int>(val)))) {
            _internal_set_severity_level(static_cast<::transit_realtime::Alert_SeverityLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedImage image = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_image(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString image_alternative_text = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_image_alternative_text(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString cause_detail = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_cause_detail(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString effect_detail = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_effect_detail(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Alert::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.Alert)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .transit_realtime.TimeRange active_period = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_active_period_size()); i < n; i++) {
    const auto& repfield = this->_internal_active_period(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_informed_entity_size()); i < n; i++) {
    const auto& repfield = this->_internal_informed_entity(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_cause(), target);
  }

  // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_effect(), target);
  }

  // optional .transit_realtime.TranslatedString url = 8;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::url(this),
        _Internal::url(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString header_text = 10;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::header_text(this),
        _Internal::header_text(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString description_text = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::description_text(this),
        _Internal::description_text(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString tts_header_text = 12;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::tts_header_text(this),
        _Internal::tts_header_text(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString tts_description_text = 13;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::tts_description_text(this),
        _Internal::tts_description_text(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this->_internal_severity_level(), target);
  }

  // optional .transit_realtime.TranslatedImage image = 15;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::image(this),
        _Internal::image(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString image_alternative_text = 16;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::image_alternative_text(this),
        _Internal::image_alternative_text(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString cause_detail = 17;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::cause_detail(this),
        _Internal::cause_detail(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString effect_detail = 18;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::effect_detail(this),
        _Internal::effect_detail(this).GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.Alert)
  return target;
}

::size_t Alert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.Alert)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.TimeRange active_period = 1;
  total_size += 1UL * this->_internal_active_period_size();
  for (const auto& msg : this->_internal_active_period()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  total_size += 1UL * this->_internal_informed_entity_size();
  for (const auto& msg : this->_internal_informed_entity()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .transit_realtime.TranslatedString url = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.url_);
    }

    // optional .transit_realtime.TranslatedString header_text = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.header_text_);
    }

    // optional .transit_realtime.TranslatedString description_text = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.description_text_);
    }

    // optional .transit_realtime.TranslatedString tts_header_text = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tts_header_text_);
    }

    // optional .transit_realtime.TranslatedString tts_description_text = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tts_description_text_);
    }

    // optional .transit_realtime.TranslatedImage image = 15;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_);
    }

    // optional .transit_realtime.TranslatedString image_alternative_text = 16;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.image_alternative_text_);
    }

    // optional .transit_realtime.TranslatedString cause_detail = 17;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.cause_detail_);
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .transit_realtime.TranslatedString effect_detail = 18;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.effect_detail_);
    }

    // optional .transit_realtime.Alert.SeverityLevel severity_level = 14 [default = UNKNOWN_SEVERITY];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_severity_level());
    }

    // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_cause());
    }

    // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_effect());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Alert::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Alert::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Alert::GetClassData() const { return &_class_data_; }


void Alert::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Alert*>(&to_msg);
  auto& from = static_cast<const Alert&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.Alert)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_active_period()->MergeFrom(from._internal_active_period());
  _this->_internal_mutable_informed_entity()->MergeFrom(from._internal_informed_entity());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_url()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_header_text()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_header_text());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_description_text()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_description_text());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_tts_header_text()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_tts_header_text());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_tts_description_text()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_tts_description_text());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_image()->::transit_realtime::TranslatedImage::MergeFrom(
          from._internal_image());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_image_alternative_text()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_image_alternative_text());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_cause_detail()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_cause_detail());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_effect_detail()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_effect_detail());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.severity_level_ = from._impl_.severity_level_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.cause_ = from._impl_.cause_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.effect_ = from._impl_.effect_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Alert::CopyFrom(const Alert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.Alert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Alert::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_active_period()))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_informed_entity()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.url_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.header_text_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.description_text_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.tts_header_text_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (!_impl_.tts_description_text_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (!_impl_.image_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (!_impl_.image_alternative_text_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (!_impl_.cause_detail_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000100u) != 0) {
    if (!_impl_.effect_detail_->IsInitialized()) return false;
  }
  return true;
}

void Alert::InternalSwap(Alert* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_active_period()->InternalSwap(other->_internal_mutable_active_period());
  _internal_mutable_informed_entity()->InternalSwap(other->_internal_mutable_informed_entity());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Alert, _impl_.effect_)
      + sizeof(Alert::_impl_.effect_)
      - PROTOBUF_FIELD_OFFSET(Alert, _impl_.url_)>(
          reinterpret_cast<char*>(&_impl_.url_),
          reinterpret_cast<char*>(&other->_impl_.url_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Alert::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[10]);
}
// ===================================================================

class TimeRange::_Internal {
 public:
  using HasBits = decltype(std::declval<TimeRange>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TimeRange, _impl_._has_bits_);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TimeRange::TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TimeRange)
}
TimeRange::TimeRange(const TimeRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TimeRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_) {}

    , decltype(_impl_.end_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  ::memcpy(&_impl_.start_, &from._impl_.start_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.end_) -
    reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.end_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TimeRange)
}

inline void TimeRange::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_) { ::uint64_t{0u} }

    , decltype(_impl_.end_) { ::uint64_t{0u} }

  };
}

TimeRange::~TimeRange() {
  // @@protoc_insertion_point(destructor:transit_realtime.TimeRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeRange::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
}

void TimeRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimeRange::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TimeRange)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.start_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_) -
        reinterpret_cast<char*>(&_impl_.start_)) + sizeof(_impl_.end_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimeRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_start(&has_bits);
          _impl_.start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_end(&has_bits);
          _impl_.end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TimeRange::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TimeRange)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        1, this->_internal_start(), target);
  }

  // optional uint64 end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        2, this->_internal_end(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TimeRange)
  return target;
}

::size_t TimeRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TimeRange)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_start());
    }

    // optional uint64 end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_end());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimeRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimeRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimeRange::GetClassData() const { return &_class_data_; }


void TimeRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimeRange*>(&to_msg);
  auto& from = static_cast<const TimeRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TimeRange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_ = from._impl_.start_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_ = from._impl_.end_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimeRange::CopyFrom(const TimeRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TimeRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeRange::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void TimeRange::InternalSwap(TimeRange* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeRange, _impl_.end_)
      + sizeof(TimeRange::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(TimeRange, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimeRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[11]);
}
// ===================================================================

class Position::_Internal {
 public:
  using HasBits = decltype(std::declval<Position>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Position, _impl_._has_bits_);
  static void set_has_latitude(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_longitude(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bearing(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_odometer(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

Position::Position(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.Position)
}
Position::Position(const Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Position* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latitude_) {}

    , decltype(_impl_.longitude_) {}

    , decltype(_impl_.odometer_) {}

    , decltype(_impl_.bearing_) {}

    , decltype(_impl_.speed_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  ::memcpy(&_impl_.latitude_, &from._impl_.latitude_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.latitude_)) + sizeof(_impl_.speed_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.Position)
}

inline void Position::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.latitude_) { 0 }

    , decltype(_impl_.longitude_) { 0 }

    , decltype(_impl_.odometer_) { 0 }

    , decltype(_impl_.bearing_) { 0 }

    , decltype(_impl_.speed_) { 0 }

  };
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:transit_realtime.Position)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Position::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
}

void Position::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.Position)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.latitude_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.latitude_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Position::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required float latitude = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 13)) {
          _Internal::set_has_latitude(&has_bits);
          _impl_.latitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // required float longitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 21)) {
          _Internal::set_has_longitude(&has_bits);
          _impl_.longitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float bearing = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 29)) {
          _Internal::set_has_bearing(&has_bits);
          _impl_.bearing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional double odometer = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_odometer(&has_bits);
          _impl_.odometer_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _Internal::set_has_speed(&has_bits);
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Position::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.Position)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required float latitude = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_latitude(), target);
  }

  // required float longitude = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_longitude(), target);
  }

  // optional float bearing = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_bearing(), target);
  }

  // optional double odometer = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_odometer(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_speed(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.Position)
  return target;
}

::size_t Position::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:transit_realtime.Position)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required float latitude = 1;
    total_size += 5;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required float longitude = 2;
    total_size += 5;
  }

  return total_size;
}
::size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.Position)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float latitude = 1;
    total_size += 5;

    // required float longitude = 2;
    total_size += 5;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional double odometer = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 9;
    }

    // optional float bearing = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 5;
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 5;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Position::GetClassData() const { return &_class_data_; }


void Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Position*>(&to_msg);
  auto& from = static_cast<const Position&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.Position)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.latitude_ = from._impl_.latitude_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.longitude_ = from._impl_.longitude_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.odometer_ = from._impl_.odometer_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bearing_ = from._impl_.bearing_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void Position::InternalSwap(Position* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Position, _impl_.speed_)
      + sizeof(Position::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(Position, _impl_.latitude_)>(
          reinterpret_cast<char*>(&_impl_.latitude_),
          reinterpret_cast<char*>(&other->_impl_.latitude_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Position::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[12]);
}
// ===================================================================

class TripDescriptor_ModifiedTripSelector::_Internal {
 public:
  using HasBits = decltype(std::declval<TripDescriptor_ModifiedTripSelector>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripDescriptor_ModifiedTripSelector, _impl_._has_bits_);
  static void set_has_modifications_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_affected_trip_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TripDescriptor_ModifiedTripSelector::TripDescriptor_ModifiedTripSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripDescriptor.ModifiedTripSelector)
}
TripDescriptor_ModifiedTripSelector::TripDescriptor_ModifiedTripSelector(const TripDescriptor_ModifiedTripSelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripDescriptor_ModifiedTripSelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modifications_id_) {}

    , decltype(_impl_.affected_trip_id_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.start_date_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.modifications_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.modifications_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.modifications_id_.Set(from._internal_modifications_id(), _this->GetArenaForAllocation());
  }
  _impl_.affected_trip_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.affected_trip_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.affected_trip_id_.Set(from._internal_affected_trip_id(), _this->GetArenaForAllocation());
  }
  _impl_.start_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_time_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.start_time_.Set(from._internal_start_time(), _this->GetArenaForAllocation());
  }
  _impl_.start_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_date_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.start_date_.Set(from._internal_start_date(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripDescriptor.ModifiedTripSelector)
}

inline void TripDescriptor_ModifiedTripSelector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modifications_id_) {}

    , decltype(_impl_.affected_trip_id_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.start_date_) {}

  };
  _impl_.modifications_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.modifications_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.affected_trip_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.affected_trip_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_time_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_date_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripDescriptor_ModifiedTripSelector::~TripDescriptor_ModifiedTripSelector() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripDescriptor.ModifiedTripSelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripDescriptor_ModifiedTripSelector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.modifications_id_.Destroy();
  _impl_.affected_trip_id_.Destroy();
  _impl_.start_time_.Destroy();
  _impl_.start_date_.Destroy();
}

void TripDescriptor_ModifiedTripSelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripDescriptor_ModifiedTripSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripDescriptor.ModifiedTripSelector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.modifications_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.affected_trip_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.start_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.start_date_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripDescriptor_ModifiedTripSelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string modifications_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_modifications_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string affected_trip_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_affected_trip_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string start_time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_start_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.ModifiedTripSelector.start_time");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string start_date = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_start_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.ModifiedTripSelector.start_date");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripDescriptor_ModifiedTripSelector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripDescriptor.ModifiedTripSelector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string modifications_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_modifications_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.ModifiedTripSelector.modifications_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string affected_trip_id = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_affected_trip_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.ModifiedTripSelector.affected_trip_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string start_time = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_start_time();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.ModifiedTripSelector.start_time");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional string start_date = 4;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_start_date();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.ModifiedTripSelector.start_date");
    target = stream->WriteStringMaybeAliased(4, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripDescriptor.ModifiedTripSelector)
  return target;
}

::size_t TripDescriptor_ModifiedTripSelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripDescriptor.ModifiedTripSelector)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string modifications_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_modifications_id());
    }

    // optional string affected_trip_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_affected_trip_id());
    }

    // optional string start_time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_start_time());
    }

    // optional string start_date = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_start_date());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripDescriptor_ModifiedTripSelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripDescriptor_ModifiedTripSelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripDescriptor_ModifiedTripSelector::GetClassData() const { return &_class_data_; }


void TripDescriptor_ModifiedTripSelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripDescriptor_ModifiedTripSelector*>(&to_msg);
  auto& from = static_cast<const TripDescriptor_ModifiedTripSelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripDescriptor.ModifiedTripSelector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_modifications_id(from._internal_modifications_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_affected_trip_id(from._internal_affected_trip_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_start_time(from._internal_start_time());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_start_date(from._internal_start_date());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripDescriptor_ModifiedTripSelector::CopyFrom(const TripDescriptor_ModifiedTripSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripDescriptor.ModifiedTripSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripDescriptor_ModifiedTripSelector::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void TripDescriptor_ModifiedTripSelector::InternalSwap(TripDescriptor_ModifiedTripSelector* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.modifications_id_, lhs_arena,
                                       &other->_impl_.modifications_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.affected_trip_id_, lhs_arena,
                                       &other->_impl_.affected_trip_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_time_, lhs_arena,
                                       &other->_impl_.start_time_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_date_, lhs_arena,
                                       &other->_impl_.start_date_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TripDescriptor_ModifiedTripSelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[13]);
}
// ===================================================================

class TripDescriptor::_Internal {
 public:
  using HasBits = decltype(std::declval<TripDescriptor>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripDescriptor, _impl_._has_bits_);
  static void set_has_trip_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_route_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_direction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_schedule_relationship(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::transit_realtime::TripDescriptor_ModifiedTripSelector& modified_trip(const TripDescriptor* msg);
  static void set_has_modified_trip(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::transit_realtime::TripDescriptor_ModifiedTripSelector&
TripDescriptor::_Internal::modified_trip(const TripDescriptor* msg) {
  return *msg->_impl_.modified_trip_;
}
TripDescriptor::TripDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripDescriptor)
}
TripDescriptor::TripDescriptor(const TripDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripDescriptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trip_id_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.start_date_) {}

    , decltype(_impl_.route_id_) {}

    , decltype(_impl_.modified_trip_){nullptr}
    , decltype(_impl_.schedule_relationship_) {}

    , decltype(_impl_.direction_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.trip_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trip_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.trip_id_.Set(from._internal_trip_id(), _this->GetArenaForAllocation());
  }
  _impl_.start_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_time_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.start_time_.Set(from._internal_start_time(), _this->GetArenaForAllocation());
  }
  _impl_.start_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_date_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.start_date_.Set(from._internal_start_date(), _this->GetArenaForAllocation());
  }
  _impl_.route_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.route_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.route_id_.Set(from._internal_route_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.modified_trip_ = new ::transit_realtime::TripDescriptor_ModifiedTripSelector(*from._impl_.modified_trip_);
  }
  ::memcpy(&_impl_.schedule_relationship_, &from._impl_.schedule_relationship_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.direction_id_) -
    reinterpret_cast<char*>(&_impl_.schedule_relationship_)) + sizeof(_impl_.direction_id_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripDescriptor)
}

inline void TripDescriptor::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trip_id_) {}

    , decltype(_impl_.start_time_) {}

    , decltype(_impl_.start_date_) {}

    , decltype(_impl_.route_id_) {}

    , decltype(_impl_.modified_trip_){nullptr}
    , decltype(_impl_.schedule_relationship_) { 0 }

    , decltype(_impl_.direction_id_) { 0u }

  };
  _impl_.trip_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.trip_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_time_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.start_date_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.start_date_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.route_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.route_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripDescriptor::~TripDescriptor() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripDescriptor::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.trip_id_.Destroy();
  _impl_.start_time_.Destroy();
  _impl_.start_date_.Destroy();
  _impl_.route_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.modified_trip_;
}

void TripDescriptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripDescriptor)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.trip_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.start_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.start_date_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.route_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.modified_trip_ != nullptr);
      _impl_.modified_trip_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&_impl_.schedule_relationship_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.direction_id_) -
        reinterpret_cast<char*>(&_impl_.schedule_relationship_)) + sizeof(_impl_.direction_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string trip_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_trip_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.trip_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string start_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_start_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.start_time");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string start_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_start_date();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.start_date");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::TripDescriptor_ScheduleRelationship_IsValid(static_cast<int>(val)))) {
            _internal_set_schedule_relationship(static_cast<::transit_realtime::TripDescriptor_ScheduleRelationship>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string route_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_route_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripDescriptor.route_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 direction_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_direction_id(&has_bits);
          _impl_.direction_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_modified_trip(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripDescriptor::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripDescriptor)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string trip_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_trip_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.trip_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string start_time = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_start_time();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.start_time");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string start_date = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_start_date();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.start_date");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_schedule_relationship(), target);
  }

  // optional string route_id = 5;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_route_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripDescriptor.route_id");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional uint32 direction_id = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_direction_id(), target);
  }

  // optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::modified_trip(this),
        _Internal::modified_trip(this).GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripDescriptor)
  return target;
}

::size_t TripDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripDescriptor)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string trip_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_trip_id());
    }

    // optional string start_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_start_time());
    }

    // optional string start_date = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_start_date());
    }

    // optional string route_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_route_id());
    }

    // optional .transit_realtime.TripDescriptor.ModifiedTripSelector modified_trip = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.modified_trip_);
    }

    // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_schedule_relationship());
    }

    // optional uint32 direction_id = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_direction_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripDescriptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripDescriptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripDescriptor::GetClassData() const { return &_class_data_; }


void TripDescriptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripDescriptor*>(&to_msg);
  auto& from = static_cast<const TripDescriptor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripDescriptor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_trip_id(from._internal_trip_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_start_time(from._internal_start_time());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_start_date(from._internal_start_date());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_route_id(from._internal_route_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_modified_trip()->::transit_realtime::TripDescriptor_ModifiedTripSelector::MergeFrom(
          from._internal_modified_trip());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.schedule_relationship_ = from._impl_.schedule_relationship_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.direction_id_ = from._impl_.direction_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripDescriptor::CopyFrom(const TripDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripDescriptor::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    if (!_impl_.modified_trip_->IsInitialized()) return false;
  }
  return true;
}

void TripDescriptor::InternalSwap(TripDescriptor* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.trip_id_, lhs_arena,
                                       &other->_impl_.trip_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_time_, lhs_arena,
                                       &other->_impl_.start_time_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.start_date_, lhs_arena,
                                       &other->_impl_.start_date_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.route_id_, lhs_arena,
                                       &other->_impl_.route_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripDescriptor, _impl_.direction_id_)
      + sizeof(TripDescriptor::_impl_.direction_id_)
      - PROTOBUF_FIELD_OFFSET(TripDescriptor, _impl_.modified_trip_)>(
          reinterpret_cast<char*>(&_impl_.modified_trip_),
          reinterpret_cast<char*>(&other->_impl_.modified_trip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TripDescriptor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[14]);
}
// ===================================================================

class VehicleDescriptor::_Internal {
 public:
  using HasBits = decltype(std::declval<VehicleDescriptor>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(VehicleDescriptor, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_license_plate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_wheelchair_accessible(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

VehicleDescriptor::VehicleDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.VehicleDescriptor)
}
VehicleDescriptor::VehicleDescriptor(const VehicleDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VehicleDescriptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.label_) {}

    , decltype(_impl_.license_plate_) {}

    , decltype(_impl_.wheelchair_accessible_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
  }
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.label_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.label_.Set(from._internal_label(), _this->GetArenaForAllocation());
  }
  _impl_.license_plate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.license_plate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.license_plate_.Set(from._internal_license_plate(), _this->GetArenaForAllocation());
  }
  _this->_impl_.wheelchair_accessible_ = from._impl_.wheelchair_accessible_;
  // @@protoc_insertion_point(copy_constructor:transit_realtime.VehicleDescriptor)
}

inline void VehicleDescriptor::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.id_) {}

    , decltype(_impl_.label_) {}

    , decltype(_impl_.license_plate_) {}

    , decltype(_impl_.wheelchair_accessible_) { 0 }

  };
  _impl_.id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.label_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.license_plate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.license_plate_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

VehicleDescriptor::~VehicleDescriptor() {
  // @@protoc_insertion_point(destructor:transit_realtime.VehicleDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VehicleDescriptor::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.id_.Destroy();
  _impl_.label_.Destroy();
  _impl_.license_plate_.Destroy();
}

void VehicleDescriptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VehicleDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.VehicleDescriptor)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.license_plate_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.wheelchair_accessible_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VehicleDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.VehicleDescriptor.id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string label = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_label();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.VehicleDescriptor.label");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string license_plate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_license_plate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.VehicleDescriptor.license_plate");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::VehicleDescriptor_WheelchairAccessible_IsValid(static_cast<int>(val)))) {
            _internal_set_wheelchair_accessible(static_cast<::transit_realtime::VehicleDescriptor_WheelchairAccessible>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* VehicleDescriptor::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.VehicleDescriptor)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.VehicleDescriptor.id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string label = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_label();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.VehicleDescriptor.label");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string license_plate = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_license_plate();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.VehicleDescriptor.license_plate");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_wheelchair_accessible(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.VehicleDescriptor)
  return target;
}

::size_t VehicleDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.VehicleDescriptor)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_id());
    }

    // optional string label = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_label());
    }

    // optional string license_plate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_license_plate());
    }

    // optional .transit_realtime.VehicleDescriptor.WheelchairAccessible wheelchair_accessible = 4 [default = NO_VALUE];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_wheelchair_accessible());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VehicleDescriptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VehicleDescriptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VehicleDescriptor::GetClassData() const { return &_class_data_; }


void VehicleDescriptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VehicleDescriptor*>(&to_msg);
  auto& from = static_cast<const VehicleDescriptor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.VehicleDescriptor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_license_plate(from._internal_license_plate());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.wheelchair_accessible_ = from._impl_.wheelchair_accessible_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VehicleDescriptor::CopyFrom(const VehicleDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.VehicleDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleDescriptor::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void VehicleDescriptor::InternalSwap(VehicleDescriptor* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena,
                                       &other->_impl_.id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.label_, lhs_arena,
                                       &other->_impl_.label_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.license_plate_, lhs_arena,
                                       &other->_impl_.license_plate_, rhs_arena);
  swap(_impl_.wheelchair_accessible_, other->_impl_.wheelchair_accessible_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VehicleDescriptor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[15]);
}
// ===================================================================

class EntitySelector::_Internal {
 public:
  using HasBits = decltype(std::declval<EntitySelector>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(EntitySelector, _impl_._has_bits_);
  static void set_has_agency_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_route_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_route_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::transit_realtime::TripDescriptor& trip(const EntitySelector* msg);
  static void set_has_trip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_stop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_direction_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::transit_realtime::TripDescriptor&
EntitySelector::_Internal::trip(const EntitySelector* msg) {
  return *msg->_impl_.trip_;
}
EntitySelector::EntitySelector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.EntitySelector)
}
EntitySelector::EntitySelector(const EntitySelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EntitySelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.agency_id_) {}

    , decltype(_impl_.route_id_) {}

    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.trip_){nullptr}
    , decltype(_impl_.route_type_) {}

    , decltype(_impl_.direction_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.agency_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.agency_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.agency_id_.Set(from._internal_agency_id(), _this->GetArenaForAllocation());
  }
  _impl_.route_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.route_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.route_id_.Set(from._internal_route_id(), _this->GetArenaForAllocation());
  }
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.stop_id_.Set(from._internal_stop_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.trip_ = new ::transit_realtime::TripDescriptor(*from._impl_.trip_);
  }
  ::memcpy(&_impl_.route_type_, &from._impl_.route_type_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.direction_id_) -
    reinterpret_cast<char*>(&_impl_.route_type_)) + sizeof(_impl_.direction_id_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.EntitySelector)
}

inline void EntitySelector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.agency_id_) {}

    , decltype(_impl_.route_id_) {}

    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.trip_){nullptr}
    , decltype(_impl_.route_type_) { 0 }

    , decltype(_impl_.direction_id_) { 0u }

  };
  _impl_.agency_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.agency_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.route_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.route_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EntitySelector::~EntitySelector() {
  // @@protoc_insertion_point(destructor:transit_realtime.EntitySelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EntitySelector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.agency_id_.Destroy();
  _impl_.route_id_.Destroy();
  _impl_.stop_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.trip_;
}

void EntitySelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EntitySelector::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.EntitySelector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.agency_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.route_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.stop_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.trip_ != nullptr);
      _impl_.trip_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.route_type_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.direction_id_) -
        reinterpret_cast<char*>(&_impl_.route_type_)) + sizeof(_impl_.direction_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EntitySelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string agency_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_agency_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.EntitySelector.agency_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string route_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_route_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.EntitySelector.route_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 route_type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_route_type(&has_bits);
          _impl_.route_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TripDescriptor trip = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_trip(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string stop_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_stop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.EntitySelector.stop_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint32 direction_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_direction_id(&has_bits);
          _impl_.direction_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* EntitySelector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.EntitySelector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string agency_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_agency_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.EntitySelector.agency_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string route_id = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_route_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.EntitySelector.route_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional int32 route_type = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_route_type(), target);
  }

  // optional .transit_realtime.TripDescriptor trip = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::trip(this),
        _Internal::trip(this).GetCachedSize(), target, stream);
  }

  // optional string stop_id = 5;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_stop_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.EntitySelector.stop_id");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional uint32 direction_id = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        6, this->_internal_direction_id(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.EntitySelector)
  return target;
}

::size_t EntitySelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.EntitySelector)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string agency_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_agency_id());
    }

    // optional string route_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_route_id());
    }

    // optional string stop_id = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_stop_id());
    }

    // optional .transit_realtime.TripDescriptor trip = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.trip_);
    }

    // optional int32 route_type = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_route_type());
    }

    // optional uint32 direction_id = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_direction_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntitySelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EntitySelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntitySelector::GetClassData() const { return &_class_data_; }


void EntitySelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EntitySelector*>(&to_msg);
  auto& from = static_cast<const EntitySelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.EntitySelector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_agency_id(from._internal_agency_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_route_id(from._internal_route_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_stop_id(from._internal_stop_id());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_trip()->::transit_realtime::TripDescriptor::MergeFrom(
          from._internal_trip());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.route_type_ = from._impl_.route_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.direction_id_ = from._impl_.direction_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EntitySelector::CopyFrom(const EntitySelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.EntitySelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntitySelector::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (!_impl_.trip_->IsInitialized()) return false;
  }
  return true;
}

void EntitySelector::InternalSwap(EntitySelector* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.agency_id_, lhs_arena,
                                       &other->_impl_.agency_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.route_id_, lhs_arena,
                                       &other->_impl_.route_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_id_, lhs_arena,
                                       &other->_impl_.stop_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EntitySelector, _impl_.direction_id_)
      + sizeof(EntitySelector::_impl_.direction_id_)
      - PROTOBUF_FIELD_OFFSET(EntitySelector, _impl_.trip_)>(
          reinterpret_cast<char*>(&_impl_.trip_),
          reinterpret_cast<char*>(&other->_impl_.trip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EntitySelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[16]);
}
// ===================================================================

class TranslatedString_Translation::_Internal {
 public:
  using HasBits = decltype(std::declval<TranslatedString_Translation>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TranslatedString_Translation, _impl_._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TranslatedString_Translation::TranslatedString_Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TranslatedString.Translation)
}
TranslatedString_Translation::TranslatedString_Translation(const TranslatedString_Translation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TranslatedString_Translation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_) {}

    , decltype(_impl_.language_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.text_.Set(from._internal_text(), _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.language_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.language_.Set(from._internal_language(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TranslatedString.Translation)
}

inline void TranslatedString_Translation::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_) {}

    , decltype(_impl_.language_) {}

  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.text_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.language_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TranslatedString_Translation::~TranslatedString_Translation() {
  // @@protoc_insertion_point(destructor:transit_realtime.TranslatedString.Translation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TranslatedString_Translation::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.text_.Destroy();
  _impl_.language_.Destroy();
}

void TranslatedString_Translation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TranslatedString_Translation::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TranslatedString.Translation)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.text_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.language_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranslatedString_Translation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TranslatedString.Translation.text");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TranslatedString.Translation.language");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TranslatedString_Translation::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TranslatedString.Translation)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string text = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_text();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TranslatedString.Translation.text");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string language = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_language();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TranslatedString.Translation.language");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TranslatedString.Translation)
  return target;
}

::size_t TranslatedString_Translation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TranslatedString.Translation)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  // required string text = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_text());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string language = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_language());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranslatedString_Translation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TranslatedString_Translation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranslatedString_Translation::GetClassData() const { return &_class_data_; }


void TranslatedString_Translation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TranslatedString_Translation*>(&to_msg);
  auto& from = static_cast<const TranslatedString_Translation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TranslatedString.Translation)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_text(from._internal_text());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_language(from._internal_language());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranslatedString_Translation::CopyFrom(const TranslatedString_Translation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TranslatedString.Translation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranslatedString_Translation::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TranslatedString_Translation::InternalSwap(TranslatedString_Translation* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.text_, lhs_arena,
                                       &other->_impl_.text_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.language_, lhs_arena,
                                       &other->_impl_.language_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TranslatedString_Translation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[17]);
}
// ===================================================================

class TranslatedString::_Internal {
 public:
};

TranslatedString::TranslatedString(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TranslatedString)
}
TranslatedString::TranslatedString(const TranslatedString& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TranslatedString* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_.translation_){from._impl_.translation_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TranslatedString)
}

inline void TranslatedString::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.translation_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TranslatedString::~TranslatedString() {
  // @@protoc_insertion_point(destructor:transit_realtime.TranslatedString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TranslatedString::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_translation()->~RepeatedPtrField();
}

void TranslatedString::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TranslatedString::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TranslatedString)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_translation()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranslatedString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .transit_realtime.TranslatedString.Translation translation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_translation(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TranslatedString::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TranslatedString)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_translation_size()); i < n; i++) {
    const auto& repfield = this->_internal_translation(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TranslatedString)
  return target;
}

::size_t TranslatedString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TranslatedString)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  total_size += 1UL * this->_internal_translation_size();
  for (const auto& msg : this->_internal_translation()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranslatedString::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TranslatedString::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranslatedString::GetClassData() const { return &_class_data_; }


void TranslatedString::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TranslatedString*>(&to_msg);
  auto& from = static_cast<const TranslatedString&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TranslatedString)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_translation()->MergeFrom(from._internal_translation());
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranslatedString::CopyFrom(const TranslatedString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TranslatedString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranslatedString::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_translation()))
    return false;
  return true;
}

void TranslatedString::InternalSwap(TranslatedString* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_translation()->InternalSwap(other->_internal_mutable_translation());
}

::PROTOBUF_NAMESPACE_ID::Metadata TranslatedString::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[18]);
}
// ===================================================================

class TranslatedImage_LocalizedImage::_Internal {
 public:
  using HasBits = decltype(std::declval<TranslatedImage_LocalizedImage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TranslatedImage_LocalizedImage, _impl_._has_bits_);
  static void set_has_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_media_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TranslatedImage_LocalizedImage::TranslatedImage_LocalizedImage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TranslatedImage.LocalizedImage)
}
TranslatedImage_LocalizedImage::TranslatedImage_LocalizedImage(const TranslatedImage_LocalizedImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TranslatedImage_LocalizedImage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_) {}

    , decltype(_impl_.media_type_) {}

    , decltype(_impl_.language_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.url_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
  }
  _impl_.media_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.media_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.media_type_.Set(from._internal_media_type(), _this->GetArenaForAllocation());
  }
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.language_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.language_.Set(from._internal_language(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TranslatedImage.LocalizedImage)
}

inline void TranslatedImage_LocalizedImage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.url_) {}

    , decltype(_impl_.media_type_) {}

    , decltype(_impl_.language_) {}

  };
  _impl_.url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.url_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.media_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.media_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.language_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.language_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TranslatedImage_LocalizedImage::~TranslatedImage_LocalizedImage() {
  // @@protoc_insertion_point(destructor:transit_realtime.TranslatedImage.LocalizedImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TranslatedImage_LocalizedImage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.url_.Destroy();
  _impl_.media_type_.Destroy();
  _impl_.language_.Destroy();
}

void TranslatedImage_LocalizedImage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TranslatedImage_LocalizedImage::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TranslatedImage.LocalizedImage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.media_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.language_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranslatedImage_LocalizedImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TranslatedImage.LocalizedImage.url");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // required string media_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_media_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TranslatedImage.LocalizedImage.media_type");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string language = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_language();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TranslatedImage.LocalizedImage.language");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TranslatedImage_LocalizedImage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TranslatedImage.LocalizedImage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required string url = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_url();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TranslatedImage.LocalizedImage.url");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // required string media_type = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_media_type();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TranslatedImage.LocalizedImage.media_type");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // optional string language = 3;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_language();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TranslatedImage.LocalizedImage.language");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TranslatedImage.LocalizedImage)
  return target;
}

::size_t TranslatedImage_LocalizedImage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:transit_realtime.TranslatedImage.LocalizedImage)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required string url = 1;
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_url());
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required string media_type = 2;
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_media_type());
  }

  return total_size;
}
::size_t TranslatedImage_LocalizedImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TranslatedImage.LocalizedImage)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string url = 1;
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_url());

    // required string media_type = 2;
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_media_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string language = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_language());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranslatedImage_LocalizedImage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TranslatedImage_LocalizedImage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranslatedImage_LocalizedImage::GetClassData() const { return &_class_data_; }


void TranslatedImage_LocalizedImage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TranslatedImage_LocalizedImage*>(&to_msg);
  auto& from = static_cast<const TranslatedImage_LocalizedImage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TranslatedImage.LocalizedImage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_url(from._internal_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_media_type(from._internal_media_type());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_language(from._internal_language());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranslatedImage_LocalizedImage::CopyFrom(const TranslatedImage_LocalizedImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TranslatedImage.LocalizedImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranslatedImage_LocalizedImage::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TranslatedImage_LocalizedImage::InternalSwap(TranslatedImage_LocalizedImage* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena,
                                       &other->_impl_.url_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.media_type_, lhs_arena,
                                       &other->_impl_.media_type_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.language_, lhs_arena,
                                       &other->_impl_.language_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TranslatedImage_LocalizedImage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[19]);
}
// ===================================================================

class TranslatedImage::_Internal {
 public:
};

TranslatedImage::TranslatedImage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TranslatedImage)
}
TranslatedImage::TranslatedImage(const TranslatedImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TranslatedImage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_.localized_image_){from._impl_.localized_image_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TranslatedImage)
}

inline void TranslatedImage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.localized_image_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TranslatedImage::~TranslatedImage() {
  // @@protoc_insertion_point(destructor:transit_realtime.TranslatedImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TranslatedImage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_localized_image()->~RepeatedPtrField();
}

void TranslatedImage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TranslatedImage::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TranslatedImage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_localized_image()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TranslatedImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_localized_image(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TranslatedImage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TranslatedImage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_localized_image_size()); i < n; i++) {
    const auto& repfield = this->_internal_localized_image(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TranslatedImage)
  return target;
}

::size_t TranslatedImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TranslatedImage)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.TranslatedImage.LocalizedImage localized_image = 1;
  total_size += 1UL * this->_internal_localized_image_size();
  for (const auto& msg : this->_internal_localized_image()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TranslatedImage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TranslatedImage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TranslatedImage::GetClassData() const { return &_class_data_; }


void TranslatedImage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TranslatedImage*>(&to_msg);
  auto& from = static_cast<const TranslatedImage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TranslatedImage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_localized_image()->MergeFrom(from._internal_localized_image());
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TranslatedImage::CopyFrom(const TranslatedImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TranslatedImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TranslatedImage::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_localized_image()))
    return false;
  return true;
}

void TranslatedImage::InternalSwap(TranslatedImage* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_localized_image()->InternalSwap(other->_internal_mutable_localized_image());
}

::PROTOBUF_NAMESPACE_ID::Metadata TranslatedImage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[20]);
}
// ===================================================================

class Shape::_Internal {
 public:
  using HasBits = decltype(std::declval<Shape>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Shape, _impl_._has_bits_);
  static void set_has_shape_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_encoded_polyline(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Shape::Shape(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.Shape)
}
Shape::Shape(const Shape& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Shape* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shape_id_) {}

    , decltype(_impl_.encoded_polyline_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.shape_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.shape_id_.Set(from._internal_shape_id(), _this->GetArenaForAllocation());
  }
  _impl_.encoded_polyline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.encoded_polyline_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.encoded_polyline_.Set(from._internal_encoded_polyline(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.Shape)
}

inline void Shape::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.shape_id_) {}

    , decltype(_impl_.encoded_polyline_) {}

  };
  _impl_.shape_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.encoded_polyline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.encoded_polyline_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Shape::~Shape() {
  // @@protoc_insertion_point(destructor:transit_realtime.Shape)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Shape::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.shape_id_.Destroy();
  _impl_.encoded_polyline_.Destroy();
}

void Shape::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Shape::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.Shape)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.shape_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.encoded_polyline_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Shape::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string shape_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_shape_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.Shape.shape_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string encoded_polyline = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_encoded_polyline();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.Shape.encoded_polyline");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Shape::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.Shape)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string shape_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_shape_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.Shape.shape_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string encoded_polyline = 2;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_encoded_polyline();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.Shape.encoded_polyline");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.Shape)
  return target;
}

::size_t Shape::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.Shape)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string shape_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_shape_id());
    }

    // optional string encoded_polyline = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_encoded_polyline());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Shape::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Shape::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Shape::GetClassData() const { return &_class_data_; }


void Shape::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Shape*>(&to_msg);
  auto& from = static_cast<const Shape&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.Shape)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_shape_id(from._internal_shape_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_encoded_polyline(from._internal_encoded_polyline());
    }
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Shape::CopyFrom(const Shape& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.Shape)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Shape::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void Shape::InternalSwap(Shape* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.shape_id_, lhs_arena,
                                       &other->_impl_.shape_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.encoded_polyline_, lhs_arena,
                                       &other->_impl_.encoded_polyline_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata Shape::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[21]);
}
// ===================================================================

class Stop::_Internal {
 public:
  using HasBits = decltype(std::declval<Stop>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(Stop, _impl_._has_bits_);
  static void set_has_stop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::transit_realtime::TranslatedString& stop_code(const Stop* msg);
  static void set_has_stop_code(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::transit_realtime::TranslatedString& stop_name(const Stop* msg);
  static void set_has_stop_name(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::transit_realtime::TranslatedString& tts_stop_name(const Stop* msg);
  static void set_has_tts_stop_name(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::transit_realtime::TranslatedString& stop_desc(const Stop* msg);
  static void set_has_stop_desc(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_stop_lat(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_stop_lon(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_zone_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::transit_realtime::TranslatedString& stop_url(const Stop* msg);
  static void set_has_stop_url(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_parent_station(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stop_timezone(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_wheelchair_boarding(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_level_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::transit_realtime::TranslatedString& platform_code(const Stop* msg);
  static void set_has_platform_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::transit_realtime::TranslatedString&
Stop::_Internal::stop_code(const Stop* msg) {
  return *msg->_impl_.stop_code_;
}
const ::transit_realtime::TranslatedString&
Stop::_Internal::stop_name(const Stop* msg) {
  return *msg->_impl_.stop_name_;
}
const ::transit_realtime::TranslatedString&
Stop::_Internal::tts_stop_name(const Stop* msg) {
  return *msg->_impl_.tts_stop_name_;
}
const ::transit_realtime::TranslatedString&
Stop::_Internal::stop_desc(const Stop* msg) {
  return *msg->_impl_.stop_desc_;
}
const ::transit_realtime::TranslatedString&
Stop::_Internal::stop_url(const Stop* msg) {
  return *msg->_impl_.stop_url_;
}
const ::transit_realtime::TranslatedString&
Stop::_Internal::platform_code(const Stop* msg) {
  return *msg->_impl_.platform_code_;
}
Stop::Stop(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.Stop)
}
Stop::Stop(const Stop& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Stop* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.zone_id_) {}

    , decltype(_impl_.parent_station_) {}

    , decltype(_impl_.stop_timezone_) {}

    , decltype(_impl_.level_id_) {}

    , decltype(_impl_.stop_code_){nullptr}
    , decltype(_impl_.stop_name_){nullptr}
    , decltype(_impl_.tts_stop_name_){nullptr}
    , decltype(_impl_.stop_desc_){nullptr}
    , decltype(_impl_.stop_url_){nullptr}
    , decltype(_impl_.platform_code_){nullptr}
    , decltype(_impl_.stop_lat_) {}

    , decltype(_impl_.stop_lon_) {}

    , decltype(_impl_.wheelchair_boarding_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.stop_id_.Set(from._internal_stop_id(), _this->GetArenaForAllocation());
  }
  _impl_.zone_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.zone_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.zone_id_.Set(from._internal_zone_id(), _this->GetArenaForAllocation());
  }
  _impl_.parent_station_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_station_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.parent_station_.Set(from._internal_parent_station(), _this->GetArenaForAllocation());
  }
  _impl_.stop_timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_timezone_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000008u) != 0) {
    _this->_impl_.stop_timezone_.Set(from._internal_stop_timezone(), _this->GetArenaForAllocation());
  }
  _impl_.level_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.level_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000010u) != 0) {
    _this->_impl_.level_id_.Set(from._internal_level_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000020u) != 0) {
    _this->_impl_.stop_code_ = new ::transit_realtime::TranslatedString(*from._impl_.stop_code_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000040u) != 0) {
    _this->_impl_.stop_name_ = new ::transit_realtime::TranslatedString(*from._impl_.stop_name_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000080u) != 0) {
    _this->_impl_.tts_stop_name_ = new ::transit_realtime::TranslatedString(*from._impl_.tts_stop_name_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000100u) != 0) {
    _this->_impl_.stop_desc_ = new ::transit_realtime::TranslatedString(*from._impl_.stop_desc_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000200u) != 0) {
    _this->_impl_.stop_url_ = new ::transit_realtime::TranslatedString(*from._impl_.stop_url_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000400u) != 0) {
    _this->_impl_.platform_code_ = new ::transit_realtime::TranslatedString(*from._impl_.platform_code_);
  }
  ::memcpy(&_impl_.stop_lat_, &from._impl_.stop_lat_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.wheelchair_boarding_) -
    reinterpret_cast<char*>(&_impl_.stop_lat_)) + sizeof(_impl_.wheelchair_boarding_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.Stop)
}

inline void Stop::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.zone_id_) {}

    , decltype(_impl_.parent_station_) {}

    , decltype(_impl_.stop_timezone_) {}

    , decltype(_impl_.level_id_) {}

    , decltype(_impl_.stop_code_){nullptr}
    , decltype(_impl_.stop_name_){nullptr}
    , decltype(_impl_.tts_stop_name_){nullptr}
    , decltype(_impl_.stop_desc_){nullptr}
    , decltype(_impl_.stop_url_){nullptr}
    , decltype(_impl_.platform_code_){nullptr}
    , decltype(_impl_.stop_lat_) { 0 }

    , decltype(_impl_.stop_lon_) { 0 }

    , decltype(_impl_.wheelchair_boarding_) { 0 }

  };
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.zone_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.zone_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.parent_station_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.parent_station_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stop_timezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_timezone_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.level_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.level_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Stop::~Stop() {
  // @@protoc_insertion_point(destructor:transit_realtime.Stop)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Stop::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.stop_id_.Destroy();
  _impl_.zone_id_.Destroy();
  _impl_.parent_station_.Destroy();
  _impl_.stop_timezone_.Destroy();
  _impl_.level_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.stop_code_;
  if (this != internal_default_instance()) delete _impl_.stop_name_;
  if (this != internal_default_instance()) delete _impl_.tts_stop_name_;
  if (this != internal_default_instance()) delete _impl_.stop_desc_;
  if (this != internal_default_instance()) delete _impl_.stop_url_;
  if (this != internal_default_instance()) delete _impl_.platform_code_;
}

void Stop::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Stop::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.Stop)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.stop_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.zone_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.parent_station_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.stop_timezone_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.level_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.stop_code_ != nullptr);
      _impl_.stop_code_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.stop_name_ != nullptr);
      _impl_.stop_name_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      ABSL_DCHECK(_impl_.tts_stop_name_ != nullptr);
      _impl_.tts_stop_name_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      ABSL_DCHECK(_impl_.stop_desc_ != nullptr);
      _impl_.stop_desc_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      ABSL_DCHECK(_impl_.stop_url_ != nullptr);
      _impl_.stop_url_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      ABSL_DCHECK(_impl_.platform_code_ != nullptr);
      _impl_.platform_code_->Clear();
    }
  }
  if (cached_has_bits & 0x00003800u) {
    ::memset(&_impl_.stop_lat_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.wheelchair_boarding_) -
        reinterpret_cast<char*>(&_impl_.stop_lat_)) + sizeof(_impl_.wheelchair_boarding_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Stop::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string stop_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.Stop.stop_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString stop_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_code(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString stop_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_name(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString tts_stop_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_tts_stop_name(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString stop_desc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_desc(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float stop_lat = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 53)) {
          _Internal::set_has_stop_lat(&has_bits);
          _impl_.stop_lat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional float stop_lon = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 61)) {
          _Internal::set_has_stop_lon(&has_bits);
          _impl_.stop_lon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string zone_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_zone_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.Stop.zone_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString stop_url = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_stop_url(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string parent_station = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_parent_station();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.Stop.parent_station");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string stop_timezone = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_stop_timezone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.Stop.stop_timezone");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 104)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::transit_realtime::Stop_WheelchairBoarding_IsValid(static_cast<int>(val)))) {
            _internal_set_wheelchair_boarding(static_cast<::transit_realtime::Stop_WheelchairBoarding>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string level_id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_level_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.Stop.level_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.TranslatedString platform_code = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_platform_code(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* Stop::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.Stop)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string stop_id = 1;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_stop_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.Stop.stop_id");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional .transit_realtime.TranslatedString stop_code = 2;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::stop_code(this),
        _Internal::stop_code(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString stop_name = 3;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::stop_name(this),
        _Internal::stop_name(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString tts_stop_name = 4;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::tts_stop_name(this),
        _Internal::tts_stop_name(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.TranslatedString stop_desc = 5;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::stop_desc(this),
        _Internal::stop_desc(this).GetCachedSize(), target, stream);
  }

  // optional float stop_lat = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_stop_lat(), target);
  }

  // optional float stop_lon = 7;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_stop_lon(), target);
  }

  // optional string zone_id = 8;
  if (cached_has_bits & 0x00000002u) {
    const std::string& _s = this->_internal_zone_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.Stop.zone_id");
    target = stream->WriteStringMaybeAliased(8, _s, target);
  }

  // optional .transit_realtime.TranslatedString stop_url = 9;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::stop_url(this),
        _Internal::stop_url(this).GetCachedSize(), target, stream);
  }

  // optional string parent_station = 11;
  if (cached_has_bits & 0x00000004u) {
    const std::string& _s = this->_internal_parent_station();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.Stop.parent_station");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // optional string stop_timezone = 12;
  if (cached_has_bits & 0x00000008u) {
    const std::string& _s = this->_internal_stop_timezone();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.Stop.stop_timezone");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        13, this->_internal_wheelchair_boarding(), target);
  }

  // optional string level_id = 14;
  if (cached_has_bits & 0x00000010u) {
    const std::string& _s = this->_internal_level_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.Stop.level_id");
    target = stream->WriteStringMaybeAliased(14, _s, target);
  }

  // optional .transit_realtime.TranslatedString platform_code = 15;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::platform_code(this),
        _Internal::platform_code(this).GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.Stop)
  return target;
}

::size_t Stop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.Stop)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string stop_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_stop_id());
    }

    // optional string zone_id = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_zone_id());
    }

    // optional string parent_station = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_parent_station());
    }

    // optional string stop_timezone = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_stop_timezone());
    }

    // optional string level_id = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_level_id());
    }

    // optional .transit_realtime.TranslatedString stop_code = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stop_code_);
    }

    // optional .transit_realtime.TranslatedString stop_name = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stop_name_);
    }

    // optional .transit_realtime.TranslatedString tts_stop_name = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tts_stop_name_);
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional .transit_realtime.TranslatedString stop_desc = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stop_desc_);
    }

    // optional .transit_realtime.TranslatedString stop_url = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stop_url_);
    }

    // optional .transit_realtime.TranslatedString platform_code = 15;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.platform_code_);
    }

    // optional float stop_lat = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += 5;
    }

    // optional float stop_lon = 7;
    if (cached_has_bits & 0x00001000u) {
      total_size += 5;
    }

    // optional .transit_realtime.Stop.WheelchairBoarding wheelchair_boarding = 13 [default = UNKNOWN];
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 +
                    ::_pbi::WireFormatLite::EnumSize(this->_internal_wheelchair_boarding());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Stop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Stop::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Stop::GetClassData() const { return &_class_data_; }


void Stop::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Stop*>(&to_msg);
  auto& from = static_cast<const Stop&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.Stop)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stop_id(from._internal_stop_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_zone_id(from._internal_zone_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_parent_station(from._internal_parent_station());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_stop_timezone(from._internal_stop_timezone());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_level_id(from._internal_level_id());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_stop_code()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_stop_code());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_stop_name()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_stop_name());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_tts_stop_name()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_tts_stop_name());
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_stop_desc()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_stop_desc());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_stop_url()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_stop_url());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_platform_code()->::transit_realtime::TranslatedString::MergeFrom(
          from._internal_platform_code());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.stop_lat_ = from._impl_.stop_lat_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.stop_lon_ = from._impl_.stop_lon_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.wheelchair_boarding_ = from._impl_.wheelchair_boarding_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Stop::CopyFrom(const Stop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.Stop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Stop::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (!_impl_.stop_code_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (!_impl_.stop_name_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (!_impl_.tts_stop_name_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000100u) != 0) {
    if (!_impl_.stop_desc_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000200u) != 0) {
    if (!_impl_.stop_url_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000400u) != 0) {
    if (!_impl_.platform_code_->IsInitialized()) return false;
  }
  return true;
}

void Stop::InternalSwap(Stop* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_id_, lhs_arena,
                                       &other->_impl_.stop_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.zone_id_, lhs_arena,
                                       &other->_impl_.zone_id_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.parent_station_, lhs_arena,
                                       &other->_impl_.parent_station_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_timezone_, lhs_arena,
                                       &other->_impl_.stop_timezone_, rhs_arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.level_id_, lhs_arena,
                                       &other->_impl_.level_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Stop, _impl_.wheelchair_boarding_)
      + sizeof(Stop::_impl_.wheelchair_boarding_)
      - PROTOBUF_FIELD_OFFSET(Stop, _impl_.stop_code_)>(
          reinterpret_cast<char*>(&_impl_.stop_code_),
          reinterpret_cast<char*>(&other->_impl_.stop_code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Stop::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[22]);
}
// ===================================================================

class TripModifications_Modification::_Internal {
 public:
  using HasBits = decltype(std::declval<TripModifications_Modification>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripModifications_Modification, _impl_._has_bits_);
  static const ::transit_realtime::StopSelector& start_stop_selector(const TripModifications_Modification* msg);
  static void set_has_start_stop_selector(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::transit_realtime::StopSelector& end_stop_selector(const TripModifications_Modification* msg);
  static void set_has_end_stop_selector(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_propagated_modification_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_service_alert_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_modified_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::transit_realtime::StopSelector&
TripModifications_Modification::_Internal::start_stop_selector(const TripModifications_Modification* msg) {
  return *msg->_impl_.start_stop_selector_;
}
const ::transit_realtime::StopSelector&
TripModifications_Modification::_Internal::end_stop_selector(const TripModifications_Modification* msg) {
  return *msg->_impl_.end_stop_selector_;
}
TripModifications_Modification::TripModifications_Modification(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripModifications.Modification)
}
TripModifications_Modification::TripModifications_Modification(const TripModifications_Modification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripModifications_Modification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.replacement_stops_){from._impl_.replacement_stops_}
    , decltype(_impl_.service_alert_id_) {}

    , decltype(_impl_.start_stop_selector_){nullptr}
    , decltype(_impl_.end_stop_selector_){nullptr}
    , decltype(_impl_.last_modified_time_) {}

    , decltype(_impl_.propagated_modification_delay_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.service_alert_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_alert_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.service_alert_id_.Set(from._internal_service_alert_id(), _this->GetArenaForAllocation());
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.start_stop_selector_ = new ::transit_realtime::StopSelector(*from._impl_.start_stop_selector_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000004u) != 0) {
    _this->_impl_.end_stop_selector_ = new ::transit_realtime::StopSelector(*from._impl_.end_stop_selector_);
  }
  ::memcpy(&_impl_.last_modified_time_, &from._impl_.last_modified_time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.propagated_modification_delay_) -
    reinterpret_cast<char*>(&_impl_.last_modified_time_)) + sizeof(_impl_.propagated_modification_delay_));
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripModifications.Modification)
}

inline void TripModifications_Modification::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.replacement_stops_){arena}
    , decltype(_impl_.service_alert_id_) {}

    , decltype(_impl_.start_stop_selector_){nullptr}
    , decltype(_impl_.end_stop_selector_){nullptr}
    , decltype(_impl_.last_modified_time_) { ::uint64_t{0u} }

    , decltype(_impl_.propagated_modification_delay_) { 0 }

  };
  _impl_.service_alert_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.service_alert_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripModifications_Modification::~TripModifications_Modification() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripModifications.Modification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripModifications_Modification::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_replacement_stops()->~RepeatedPtrField();
  _impl_.service_alert_id_.Destroy();
  if (this != internal_default_instance()) delete _impl_.start_stop_selector_;
  if (this != internal_default_instance()) delete _impl_.end_stop_selector_;
}

void TripModifications_Modification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripModifications_Modification::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripModifications.Modification)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_replacement_stops()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.service_alert_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.start_stop_selector_ != nullptr);
      _impl_.start_stop_selector_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.end_stop_selector_ != nullptr);
      _impl_.end_stop_selector_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.last_modified_time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.propagated_modification_delay_) -
        reinterpret_cast<char*>(&_impl_.last_modified_time_)) + sizeof(_impl_.propagated_modification_delay_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripModifications_Modification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .transit_realtime.StopSelector start_stop_selector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_stop_selector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .transit_realtime.StopSelector end_stop_selector = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end_stop_selector(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional int32 propagated_modification_delay = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_propagated_modification_delay(&has_bits);
          _impl_.propagated_modification_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .transit_realtime.ReplacementStop replacement_stops = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_replacement_stops(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string service_alert_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_service_alert_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripModifications.Modification.service_alert_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      // optional uint64 last_modified_time = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          _Internal::set_has_last_modified_time(&has_bits);
          _impl_.last_modified_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripModifications_Modification::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripModifications.Modification)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .transit_realtime.StopSelector start_stop_selector = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::start_stop_selector(this),
        _Internal::start_stop_selector(this).GetCachedSize(), target, stream);
  }

  // optional .transit_realtime.StopSelector end_stop_selector = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::end_stop_selector(this),
        _Internal::end_stop_selector(this).GetCachedSize(), target, stream);
  }

  // optional int32 propagated_modification_delay = 3 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        3, this->_internal_propagated_modification_delay(), target);
  }

  // repeated .transit_realtime.ReplacementStop replacement_stops = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_replacement_stops_size()); i < n; i++) {
    const auto& repfield = this->_internal_replacement_stops(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string service_alert_id = 5;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_service_alert_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripModifications.Modification.service_alert_id");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional uint64 last_modified_time = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        6, this->_internal_last_modified_time(), target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripModifications.Modification)
  return target;
}

::size_t TripModifications_Modification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripModifications.Modification)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.ReplacementStop replacement_stops = 4;
  total_size += 1UL * this->_internal_replacement_stops_size();
  for (const auto& msg : this->_internal_replacement_stops()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string service_alert_id = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_service_alert_id());
    }

    // optional .transit_realtime.StopSelector start_stop_selector = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_stop_selector_);
    }

    // optional .transit_realtime.StopSelector end_stop_selector = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_stop_selector_);
    }

    // optional uint64 last_modified_time = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this->_internal_last_modified_time());
    }

    // optional int32 propagated_modification_delay = 3 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_propagated_modification_delay());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripModifications_Modification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripModifications_Modification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripModifications_Modification::GetClassData() const { return &_class_data_; }


void TripModifications_Modification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripModifications_Modification*>(&to_msg);
  auto& from = static_cast<const TripModifications_Modification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripModifications.Modification)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_replacement_stops()->MergeFrom(from._internal_replacement_stops());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_service_alert_id(from._internal_service_alert_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start_stop_selector()->::transit_realtime::StopSelector::MergeFrom(
          from._internal_start_stop_selector());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end_stop_selector()->::transit_realtime::StopSelector::MergeFrom(
          from._internal_end_stop_selector());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.last_modified_time_ = from._impl_.last_modified_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.propagated_modification_delay_ = from._impl_.propagated_modification_delay_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripModifications_Modification::CopyFrom(const TripModifications_Modification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripModifications.Modification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripModifications_Modification::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_replacement_stops()))
    return false;
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.start_stop_selector_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!_impl_.end_stop_selector_->IsInitialized()) return false;
  }
  return true;
}

void TripModifications_Modification::InternalSwap(TripModifications_Modification* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_replacement_stops()->InternalSwap(other->_internal_mutable_replacement_stops());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.service_alert_id_, lhs_arena,
                                       &other->_impl_.service_alert_id_, rhs_arena);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TripModifications_Modification, _impl_.propagated_modification_delay_)
      + sizeof(TripModifications_Modification::_impl_.propagated_modification_delay_)
      - PROTOBUF_FIELD_OFFSET(TripModifications_Modification, _impl_.start_stop_selector_)>(
          reinterpret_cast<char*>(&_impl_.start_stop_selector_),
          reinterpret_cast<char*>(&other->_impl_.start_stop_selector_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TripModifications_Modification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[23]);
}
// ===================================================================

class TripModifications_SelectedTrips::_Internal {
 public:
  using HasBits = decltype(std::declval<TripModifications_SelectedTrips>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TripModifications_SelectedTrips, _impl_._has_bits_);
  static void set_has_shape_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TripModifications_SelectedTrips::TripModifications_SelectedTrips(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripModifications.SelectedTrips)
}
TripModifications_SelectedTrips::TripModifications_SelectedTrips(const TripModifications_SelectedTrips& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripModifications_SelectedTrips* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trip_ids_){from._impl_.trip_ids_}
    , decltype(_impl_.shape_id_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.shape_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.shape_id_.Set(from._internal_shape_id(), _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripModifications.SelectedTrips)
}

inline void TripModifications_SelectedTrips::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.trip_ids_){arena}
    , decltype(_impl_.shape_id_) {}

  };
  _impl_.shape_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.shape_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TripModifications_SelectedTrips::~TripModifications_SelectedTrips() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripModifications.SelectedTrips)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripModifications_SelectedTrips::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_trip_ids()->~RepeatedPtrField();
  _impl_.shape_id_.Destroy();
}

void TripModifications_SelectedTrips::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripModifications_SelectedTrips::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripModifications.SelectedTrips)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_trip_ids()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.shape_id_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripModifications_SelectedTrips::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string trip_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_trip_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "transit_realtime.TripModifications.SelectedTrips.trip_ids");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string shape_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_shape_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.TripModifications.SelectedTrips.shape_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripModifications_SelectedTrips::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripModifications.SelectedTrips)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string trip_ids = 1;
  for (int i = 0, n = this->_internal_trip_ids_size(); i < n; ++i) {
    const auto& s = this->_internal_trip_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripModifications.SelectedTrips.trip_ids");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional string shape_id = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_shape_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripModifications.SelectedTrips.shape_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripModifications.SelectedTrips)
  return target;
}

::size_t TripModifications_SelectedTrips::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripModifications.SelectedTrips)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string trip_ids = 1;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_trip_ids().size());
  for (int i = 0, n = _internal_trip_ids().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_trip_ids().Get(i));
  }

  // optional string shape_id = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                    this->_internal_shape_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripModifications_SelectedTrips::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripModifications_SelectedTrips::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripModifications_SelectedTrips::GetClassData() const { return &_class_data_; }


void TripModifications_SelectedTrips::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripModifications_SelectedTrips*>(&to_msg);
  auto& from = static_cast<const TripModifications_SelectedTrips&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripModifications.SelectedTrips)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_trip_ids()->MergeFrom(from._internal_trip_ids());
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_shape_id(from._internal_shape_id());
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripModifications_SelectedTrips::CopyFrom(const TripModifications_SelectedTrips& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripModifications.SelectedTrips)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripModifications_SelectedTrips::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void TripModifications_SelectedTrips::InternalSwap(TripModifications_SelectedTrips* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_trip_ids()->InternalSwap(
      other->_internal_mutable_trip_ids());
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.shape_id_, lhs_arena,
                                       &other->_impl_.shape_id_, rhs_arena);
}

::PROTOBUF_NAMESPACE_ID::Metadata TripModifications_SelectedTrips::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[24]);
}
// ===================================================================

class TripModifications::_Internal {
 public:
};

TripModifications::TripModifications(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.TripModifications)
}
TripModifications::TripModifications(const TripModifications& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TripModifications* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_.selected_trips_){from._impl_.selected_trips_}
    , decltype(_impl_.start_times_){from._impl_.start_times_}
    , decltype(_impl_.service_dates_){from._impl_.service_dates_}
    , decltype(_impl_.modifications_){from._impl_.modifications_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  // @@protoc_insertion_point(copy_constructor:transit_realtime.TripModifications)
}

inline void TripModifications::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.selected_trips_){arena}
    , decltype(_impl_.start_times_){arena}
    , decltype(_impl_.service_dates_){arena}
    , decltype(_impl_.modifications_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TripModifications::~TripModifications() {
  // @@protoc_insertion_point(destructor:transit_realtime.TripModifications)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TripModifications::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _internal_mutable_selected_trips()->~RepeatedPtrField();
  _internal_mutable_start_times()->~RepeatedPtrField();
  _internal_mutable_service_dates()->~RepeatedPtrField();
  _internal_mutable_modifications()->~RepeatedPtrField();
}

void TripModifications::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TripModifications::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.TripModifications)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  _internal_mutable_selected_trips()->Clear();
  _internal_mutable_start_times()->Clear();
  _internal_mutable_service_dates()->Clear();
  _internal_mutable_modifications()->Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TripModifications::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_selected_trips(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string start_times = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_start_times();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "transit_realtime.TripModifications.start_times");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated string service_dates = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_service_dates();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "transit_realtime.TripModifications.service_dates");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .transit_realtime.TripModifications.Modification modifications = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modifications(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TripModifications::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.TripModifications)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_selected_trips_size()); i < n; i++) {
    const auto& repfield = this->_internal_selected_trips(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string start_times = 2;
  for (int i = 0, n = this->_internal_start_times_size(); i < n; ++i) {
    const auto& s = this->_internal_start_times(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripModifications.start_times");
    target = stream->WriteString(2, s, target);
  }

  // repeated string service_dates = 3;
  for (int i = 0, n = this->_internal_service_dates_size(); i < n; ++i) {
    const auto& s = this->_internal_service_dates(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(s.data(), static_cast<int>(s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.TripModifications.service_dates");
    target = stream->WriteString(3, s, target);
  }

  // repeated .transit_realtime.TripModifications.Modification modifications = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_modifications_size()); i < n; i++) {
    const auto& repfield = this->_internal_modifications(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.TripModifications)
  return target;
}

::size_t TripModifications::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.TripModifications)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .transit_realtime.TripModifications.SelectedTrips selected_trips = 1;
  total_size += 1UL * this->_internal_selected_trips_size();
  for (const auto& msg : this->_internal_selected_trips()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string start_times = 2;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_start_times().size());
  for (int i = 0, n = _internal_start_times().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_start_times().Get(i));
  }

  // repeated string service_dates = 3;
  total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_internal_service_dates().size());
  for (int i = 0, n = _internal_service_dates().size(); i < n; ++i) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        _internal_service_dates().Get(i));
  }

  // repeated .transit_realtime.TripModifications.Modification modifications = 4;
  total_size += 1UL * this->_internal_modifications_size();
  for (const auto& msg : this->_internal_modifications()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TripModifications::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TripModifications::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TripModifications::GetClassData() const { return &_class_data_; }


void TripModifications::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TripModifications*>(&to_msg);
  auto& from = static_cast<const TripModifications&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.TripModifications)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_selected_trips()->MergeFrom(from._internal_selected_trips());
  _this->_internal_mutable_start_times()->MergeFrom(from._internal_start_times());
  _this->_internal_mutable_service_dates()->MergeFrom(from._internal_service_dates());
  _this->_internal_mutable_modifications()->MergeFrom(from._internal_modifications());
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TripModifications::CopyFrom(const TripModifications& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.TripModifications)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TripModifications::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_selected_trips()))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_modifications()))
    return false;
  return true;
}

void TripModifications::InternalSwap(TripModifications* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _internal_mutable_selected_trips()->InternalSwap(other->_internal_mutable_selected_trips());
  _internal_mutable_start_times()->InternalSwap(
      other->_internal_mutable_start_times());
  _internal_mutable_service_dates()->InternalSwap(
      other->_internal_mutable_service_dates());
  _internal_mutable_modifications()->InternalSwap(other->_internal_mutable_modifications());
}

::PROTOBUF_NAMESPACE_ID::Metadata TripModifications::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[25]);
}
// ===================================================================

class StopSelector::_Internal {
 public:
  using HasBits = decltype(std::declval<StopSelector>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(StopSelector, _impl_._has_bits_);
  static void set_has_stop_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StopSelector::StopSelector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.StopSelector)
}
StopSelector::StopSelector(const StopSelector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StopSelector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.stop_sequence_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.stop_id_.Set(from._internal_stop_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.stop_sequence_ = from._impl_.stop_sequence_;
  // @@protoc_insertion_point(copy_constructor:transit_realtime.StopSelector)
}

inline void StopSelector::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.stop_sequence_) { 0u }

  };
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StopSelector::~StopSelector() {
  // @@protoc_insertion_point(destructor:transit_realtime.StopSelector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StopSelector::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.stop_id_.Destroy();
}

void StopSelector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StopSelector::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.StopSelector)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stop_id_.ClearNonDefaultToEmpty();
  }
  _impl_.stop_sequence_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StopSelector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 stop_sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_stop_sequence(&has_bits);
          _impl_.stop_sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string stop_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.StopSelector.stop_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* StopSelector::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.StopSelector)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 stop_sequence = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_stop_sequence(), target);
  }

  // optional string stop_id = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_stop_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.StopSelector.stop_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.StopSelector)
  return target;
}

::size_t StopSelector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.StopSelector)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string stop_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_stop_id());
    }

    // optional uint32 stop_sequence = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
          this->_internal_stop_sequence());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StopSelector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StopSelector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StopSelector::GetClassData() const { return &_class_data_; }


void StopSelector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StopSelector*>(&to_msg);
  auto& from = static_cast<const StopSelector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.StopSelector)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stop_id(from._internal_stop_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.stop_sequence_ = from._impl_.stop_sequence_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StopSelector::CopyFrom(const StopSelector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.StopSelector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StopSelector::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void StopSelector::InternalSwap(StopSelector* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_id_, lhs_arena,
                                       &other->_impl_.stop_id_, rhs_arena);

  swap(_impl_.stop_sequence_, other->_impl_.stop_sequence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StopSelector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[26]);
}
// ===================================================================

class ReplacementStop::_Internal {
 public:
  using HasBits = decltype(std::declval<ReplacementStop>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ReplacementStop, _impl_._has_bits_);
  static void set_has_travel_time_to_stop(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stop_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ReplacementStop::ReplacementStop(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:transit_realtime.ReplacementStop)
}
ReplacementStop::ReplacementStop(const ReplacementStop& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReplacementStop* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{}
    , decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.travel_time_to_stop_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.stop_id_.Set(from._internal_stop_id(), _this->GetArenaForAllocation());
  }
  _this->_impl_.travel_time_to_stop_ = from._impl_.travel_time_to_stop_;
  // @@protoc_insertion_point(copy_constructor:transit_realtime.ReplacementStop)
}

inline void ReplacementStop::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      /*decltype(_impl_._extensions_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.stop_id_) {}

    , decltype(_impl_.travel_time_to_stop_) { 0 }

  };
  _impl_.stop_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        _impl_.stop_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReplacementStop::~ReplacementStop() {
  // @@protoc_insertion_point(destructor:transit_realtime.ReplacementStop)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReplacementStop::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_._extensions_.~ExtensionSet();
  _impl_.stop_id_.Destroy();
}

void ReplacementStop::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReplacementStop::Clear() {
// @@protoc_insertion_point(message_clear_start:transit_realtime.ReplacementStop)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_._extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.stop_id_.ClearNonDefaultToEmpty();
  }
  _impl_.travel_time_to_stop_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReplacementStop::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 travel_time_to_stop = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_travel_time_to_stop(&has_bits);
          _impl_.travel_time_to_stop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional string stop_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stop_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "transit_realtime.ReplacementStop.stop_id");
          #endif  // !NDEBUG
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    if ((8000u <= tag && tag < 16000u) ||
    (72000u <= tag && tag < 80000u)) {
      ptr = _impl_._extensions_.ParseField(tag, ptr, internal_default_instance(), &_internal_metadata_, ctx);
      CHK_(ptr != nullptr);
      continue;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReplacementStop::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:transit_realtime.ReplacementStop)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 travel_time_to_stop = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_travel_time_to_stop(), target);
  }

  // optional string stop_id = 2;
  if (cached_has_bits & 0x00000001u) {
    const std::string& _s = this->_internal_stop_id();
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(_s.data(), static_cast<int>(_s.length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
                                "transit_realtime.ReplacementStop.stop_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  // Extension range [1000, 10000)
  target = _impl_._extensions_._InternalSerialize(
  internal_default_instance(), 1000, 10000, target, stream);

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:transit_realtime.ReplacementStop)
  return target;
}

::size_t ReplacementStop::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:transit_realtime.ReplacementStop)
  ::size_t total_size = 0;

  total_size += _impl_._extensions_.ByteSize();

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string stop_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                                      this->_internal_stop_id());
    }

    // optional int32 travel_time_to_stop = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
          this->_internal_travel_time_to_stop());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReplacementStop::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReplacementStop::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReplacementStop::GetClassData() const { return &_class_data_; }


void ReplacementStop::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReplacementStop*>(&to_msg);
  auto& from = static_cast<const ReplacementStop&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:transit_realtime.ReplacementStop)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_stop_id(from._internal_stop_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.travel_time_to_stop_ = from._impl_.travel_time_to_stop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_impl_._extensions_.MergeFrom(internal_default_instance(), from._impl_._extensions_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReplacementStop::CopyFrom(const ReplacementStop& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:transit_realtime.ReplacementStop)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReplacementStop::IsInitialized() const {
  if (!_impl_._extensions_.IsInitialized(internal_default_instance())) {
    return false;
  }

  return true;
}

void ReplacementStop::InternalSwap(ReplacementStop* other) {
  using std::swap;
  _impl_._extensions_.InternalSwap(&other->_impl_._extensions_);
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.stop_id_, lhs_arena,
                                       &other->_impl_.stop_id_, rhs_arena);

  swap(_impl_.travel_time_to_stop_, other->_impl_.travel_time_to_stop_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReplacementStop::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_gtfs_2drealtime_2eproto_getter, &descriptor_table_gtfs_2drealtime_2eproto_once,
      file_level_metadata_gtfs_2drealtime_2eproto[27]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace transit_realtime
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::transit_realtime::FeedMessage*
Arena::CreateMaybeMessage< ::transit_realtime::FeedMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::FeedMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::FeedHeader*
Arena::CreateMaybeMessage< ::transit_realtime::FeedHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::FeedHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::FeedEntity*
Arena::CreateMaybeMessage< ::transit_realtime::FeedEntity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::FeedEntity >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripUpdate_StopTimeEvent*
Arena::CreateMaybeMessage< ::transit_realtime::TripUpdate_StopTimeEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripUpdate_StopTimeEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties*
Arena::CreateMaybeMessage< ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripUpdate_StopTimeUpdate_StopTimeProperties >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripUpdate_StopTimeUpdate*
Arena::CreateMaybeMessage< ::transit_realtime::TripUpdate_StopTimeUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripUpdate_StopTimeUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripUpdate_TripProperties*
Arena::CreateMaybeMessage< ::transit_realtime::TripUpdate_TripProperties >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripUpdate_TripProperties >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripUpdate*
Arena::CreateMaybeMessage< ::transit_realtime::TripUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::VehiclePosition_CarriageDetails*
Arena::CreateMaybeMessage< ::transit_realtime::VehiclePosition_CarriageDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::VehiclePosition_CarriageDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::VehiclePosition*
Arena::CreateMaybeMessage< ::transit_realtime::VehiclePosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::VehiclePosition >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::Alert*
Arena::CreateMaybeMessage< ::transit_realtime::Alert >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::Alert >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TimeRange*
Arena::CreateMaybeMessage< ::transit_realtime::TimeRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TimeRange >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::Position*
Arena::CreateMaybeMessage< ::transit_realtime::Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::Position >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripDescriptor_ModifiedTripSelector*
Arena::CreateMaybeMessage< ::transit_realtime::TripDescriptor_ModifiedTripSelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripDescriptor_ModifiedTripSelector >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripDescriptor*
Arena::CreateMaybeMessage< ::transit_realtime::TripDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::VehicleDescriptor*
Arena::CreateMaybeMessage< ::transit_realtime::VehicleDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::VehicleDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::EntitySelector*
Arena::CreateMaybeMessage< ::transit_realtime::EntitySelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::EntitySelector >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TranslatedString_Translation*
Arena::CreateMaybeMessage< ::transit_realtime::TranslatedString_Translation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TranslatedString_Translation >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TranslatedString*
Arena::CreateMaybeMessage< ::transit_realtime::TranslatedString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TranslatedString >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TranslatedImage_LocalizedImage*
Arena::CreateMaybeMessage< ::transit_realtime::TranslatedImage_LocalizedImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TranslatedImage_LocalizedImage >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TranslatedImage*
Arena::CreateMaybeMessage< ::transit_realtime::TranslatedImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TranslatedImage >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::Shape*
Arena::CreateMaybeMessage< ::transit_realtime::Shape >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::Shape >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::Stop*
Arena::CreateMaybeMessage< ::transit_realtime::Stop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::Stop >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripModifications_Modification*
Arena::CreateMaybeMessage< ::transit_realtime::TripModifications_Modification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripModifications_Modification >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripModifications_SelectedTrips*
Arena::CreateMaybeMessage< ::transit_realtime::TripModifications_SelectedTrips >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripModifications_SelectedTrips >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::TripModifications*
Arena::CreateMaybeMessage< ::transit_realtime::TripModifications >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::TripModifications >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::StopSelector*
Arena::CreateMaybeMessage< ::transit_realtime::StopSelector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::StopSelector >(arena);
}
template<> PROTOBUF_NOINLINE ::transit_realtime::ReplacementStop*
Arena::CreateMaybeMessage< ::transit_realtime::ReplacementStop >(Arena* arena) {
  return Arena::CreateMessageInternal< ::transit_realtime::ReplacementStop >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"

#ifdef _MSC_VER
#include "Windows/HideWindowsPlatformTypes.h"
#endif